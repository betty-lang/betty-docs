{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the official documentation for Betty, a dynamic programming language designed for prototyping purposes. Betty supports various data types, a standard library, and offers a simple and intuitive syntax.</p> <p>Warning</p> <p>This documentation is still a work in progress and does not cover all language features yet. Please check back for future updates!</p>"},{"location":"data-types/boolean/","title":"Boolean","text":"<p>Boolean literals are represented with the <code>true</code> and <code>false</code> keywords, which are language-reserved and may not be used in another context. Logical operations in Betty require both operands to be of type <code>Boolean</code>. No implicit conversions between booleans and numeric values exist.</p> <pre><code>a = true;\n</code></pre>"},{"location":"data-types/char/","title":"Char","text":"<p>Character literals are encased between a pair of single quotes ( <code>'</code> ). Empty character literals are not allowed in Betty programs. A character literal may not consist of more than one character, save for escape sequences\u2014which essentially are single characters.</p> <pre><code>x = 'b';    # Valid\nx = '\\n';   # Valid, escape sequence\nx = '';     # Will throw, empty character literal\nx = 'ab';   # Will throw, multi-character literal\nx = ';      # Will throw, unterminated character literal\n</code></pre> <p>Note</p> <p>Some operations between numbers and characters (character arithmetic) are handled implicitly by the interpreter, to an extent. Refer to the operator documentation syntax for further details, as well as to explore options for handling such operations explicitly.</p>"},{"location":"data-types/list/","title":"List","text":"<p>Lists are currently the sole data structure of the Betty language, its bread and butter so to speak. Aided by the language's dynamic design, lists are very versatile in terms of their usage and what they can accomplish.</p> <p>Betty allows lists containing multiple data types, even different (nested) lists. Despite the lack of other data structures in the language, the flexibility achieved through this alone enables for \"custom\" record-like structures, even\u2014admittedly lesser-performing\u2014 maps.</p> <p>Note</p> <p>In the code examples section of the documentation, you can find a partial, preliminary attempt at bootstrapping (self-hosting) the Betty interpreter, showcasing the language's potential. Naturally, although such an implementation would result in less-than-ideal execution times, it is nonetheless a rather fun theoretical endeavor to take on.</p> <p>Betty is primarily a prototyping language, that much is certain. Be that as it may, the presence of lists\u2014along with some useful standard library functions, can assist the user in coding solutions to a multitude of problems. That was a major consideration in the way lists are implemented.</p> <p>One of the goals in the development process was to provide the programmer with ways to create something more meaningful than your typical \"Hello World,\" even at the cost of potential performance (the unavoidable tree-walk interpreter baggage). Whether they decide to \"get their hands dirty\" is ultimately left up to the user.</p> <pre><code>x = [1, 2, 3, 4];\nx = [1..5];             # Same declaration with range syntax\nx = [[1, 2], [3, 4]];   # Nested lists\n</code></pre>"},{"location":"data-types/list/#string-indexing","title":"String indexing","text":"<p>Betty supports indexing strings and accessing them as character lists out-of-the-box, in alignment with the default behavior in various programming languages.</p> <pre><code>print(\"hello\"[1]); # Will print `e`\n</code></pre>"},{"location":"data-types/none/","title":"None","text":"<p><code>None</code> is a special data type, in terms of how it works in Betty. It is not one of the language's keywords and neither variables nor functions can be assigned it. </p> <p>Nullability support can be a rather controversial topic among language designers, as including support for it could potentially lead to a plethora of runtime errors, like when dereferencing null pointers.</p> <p>What is more, extending a language to support null and nullable types can introduce a whole new layer of complexity (oftentimes unnecessary).</p> <p>However, allowing implicit returns of a <code>unit</code>-like value (<code>None</code>, in our case) can be beneficial in handling cases like the default return value of functions. Betty is a dynamic language, therefore a single function can return multiple data types. Introducing a default return value mitigates a significant class of potential issues and ensures all code paths have a return value.</p> <p>Under the hood, it is far more convenient to implement a visitor pattern in the interpreter, when all node visits result in the return of a uniform <code>Value</code> struct (with <code>None</code> as a potential value type). In this manner, there's no need for special handling of uninitialized or absent returns in dynamic typing contexts. It also avoids runtime surprises when a function unexpectedly fails to return a value.</p> <p>It should further be noted that since Betty allows expression-statements as first-class citizens, functions can be executed solely for their side effects and have their values discarded.</p> <pre><code>print(\"Hello, world!\"); # Valid, clearly intended for the side effect.\n</code></pre>"},{"location":"data-types/number/","title":"Number","text":"<p>Betty uses a universal <code>number</code> data type to represent both integers and real numbers. Internally, all numeric values are stored as <code>double</code> for ease of handling. The language does, in fact, offer ways to work with strictly integer values, at least on the surface level, should one wish to do so.</p> <p>For instance, there are built-in math functions baked into the language for both <code>floor()</code> and <code>ceil()</code>. Additionally, there exists an integer division operator ( <code>//</code> ), which performs normal double division then floors the result, as is the case in several programming languages (e.g. Python, Ruby).</p> <pre><code>12\n0.5\n0.002\n-3\n</code></pre> <p>Under the hood, Betty leverages C#'s and, by extension, .NET's own <code>double</code> primitive value type, which means edge cases such as <code>infinity</code> and <code>NaN</code> are handled by the underlying framework implementation at the binary level.</p>"},{"location":"data-types/string/","title":"String","text":"<p>Strings in Betty are enclosed between a pair of double quotes ( <code>\"</code> ). They are interned using a string lookup table so they can be lightweight\u2014in terms of memory overhead and allocations (on the stack vs. the heap), as well as be accessed very fast in ideal usage scenarios.</p> <pre><code>\"Hello, World!\";\n</code></pre> <p>In an addition operation, if either operand is a <code>string</code>, then the result is concatenated and returned as a <code>string</code>. This has been implemented to match the expected behavior in several programming languages.</p> <pre><code>\"Hi \" + 5; # Returns \"Hi 5\"\n</code></pre> <p>Furthermore, in addition to equality and inequality operations, strings allow comparisons like <code>&gt;</code> and <code>&lt;</code>, based on lexicographical order. This behavior may not always make intuitive sense to a newer programmer, nonetheless it is supported in plenty of programming languages. In the back-end, C#'s <code>CompareTo</code> standard library function (akin to <code>strcmp</code> in C) is utilized.</p> <pre><code>\"apple\" &lt; \"banana\"; # Returns `true`, since 'a' is less than 'b'\n</code></pre> <p>Compound (shorthand assignment) is supported in strings only through the addition ( <code>+</code> ) operator.</p>"},{"location":"data-types/string/#escape-sequences","title":"Escape sequences","text":"Sequence Description <code>\\n</code> Newline <code>\\t</code> Tab <code>\\\"</code> Double quote <code>\\'</code> Single quote <code>\\\\</code> Backslash <code>\\0</code> Null character <p>Note</p> <p>Character literals also support the aforementioned sequences.</p>"},{"location":"operators/arithmetic/","title":"Arithmetic Operators","text":"Operator Description Example <code>+</code> Addition <code>1 + 2</code> \u2192 <code>3</code> <code>-</code> Subtraction <code>5 - 3</code> \u2192 <code>2</code> <code>*</code> Multiplication <code>4 * 2</code> \u2192 <code>8</code> <code>/</code> Division <code>8 / 2</code> \u2192 <code>4</code> <code>%</code> Modulus <code>10 % 3</code> \u2192 <code>1</code> <code>^</code> Exponentiation <code>2 ^ 3</code> \u2192 <code>8</code> <code>//</code> Floor Division <code>7 // 2</code> \u2192 <code>3</code>"},{"location":"operators/arithmetic/#addition-overloads","title":"Addition overloads","text":""},{"location":"operators/arithmetic/#string-concatenation","title":"String concatenation","text":"<p>The addition operator has been overloaded to support string concatenation. Therefore, syntax such as <code>\"Hello \" + \"World\"</code> is possible in Betty.</p> <p>Note</p> <p>String concatenation is also supported through an appropriately-named <code>concat()</code> built-in language function, as well as the <code>print()</code> function itself. Further examples of string manipulation can be found in the intrinsic functions documentation.</p>"},{"location":"operators/arithmetic/#list-operand-addition","title":"List-operand addition","text":"<p>If either operand of an addition operation is a <code>list</code>, the interpreter will append the other operand to it\u2014either at the beginning or the end, depending on the operand order. If both operands are lists, the second list will be appended to the end of the first.</p> <p>Since lists are reference types in Betty, this operation modifies the original list rather than creating a new one.</p> <p>Cases:</p> <ul> <li><code>list + element</code> would append <code>element</code> to the end of <code>list</code>.</li> <li><code>element + list</code> would prepend <code>element</code> to the beginning of <code>list</code>.</li> <li><code>list1 + list2</code> would append <code>list2</code> to <code>list1</code>, modifying <code>list1</code>.</li> </ul> <p>Example:</p> <pre><code>a = \"hello\";\nb = [1, 2];\nreturn b + a; # Will append the string to the end of `b`, i.e. [1, 2, \"hello\"]\n</code></pre>"},{"location":"operators/arithmetic/#implicit-conversions","title":"Implicit conversions","text":"<p>For the sake of convenience and flexibility, Betty will handle some common scenarios implicitly, as far as the expected outcome of \"adding\" different data types is concerned. For those who prefer boldness and completeness over simplicity\u2014although type hinting is not a feature\u2014the language constructs do allow you to explicitly specify most conversion operations.</p>"},{"location":"operators/arithmetic/#character-arithmetic","title":"Character arithmetic","text":"<p>In Betty, characters are implicitly converted to their ASCII values when used in arithmetic operations. This allows direct manipulation of characters as numeric values.</p> <pre><code>charValue = 'a';\ncharValue += 1;         # Implicitly converts 'a' to its ASCII value, then increments\nprint(charValue);       # Outputs the number corresponding to 'b' in ASCII\nnumberValue = 10;\nnumberValue += '3';     # '3' is implicitly converted to its numeric ASCII value before addition\nprint(numberValue);     # Outputs the result of the addition\n</code></pre> <p>Note</p> <p>As types in Betty are, for the most part, not strictly enforced, the interpreter will automatically handle conversions like these to reduce friction and boilerplate code.</p> <p>Warning</p> <p>In order to avoid confusion and ensure clarity, an explicit conversion back to <code>char</code> would be needed in order to print the character representations in the example.</p>"},{"location":"operators/assignment/","title":"Assignment Operators","text":"Operator Description Example Equivalent To <code>=</code> Assign value <code>x = 5</code> <code>x = 5</code>"},{"location":"operators/assignment/#compound-assignment","title":"Compound assignment","text":"Operator Description Example Equivalent To <code>+=</code> Add and assign <code>x += 3</code> <code>x = x + 3</code> <code>-=</code> Subtract and assign <code>x -= 2</code> <code>x = x - 2</code> <code>*=</code> Multiply and assign <code>x *= 4</code> <code>x = x * 4</code> <code>/=</code> Divide and assign <code>x /= 2</code> <code>x = x / 2</code> <code>%=</code> Modulus and assign <code>x %= 3</code> <code>x = x % 3</code> <code>**=</code> Exponentiate and assign <code>x ^= 2</code> <code>x = x ^ 2</code> <code>//=</code> Floor divide and assign <code>x //= 2</code> <code>x = x // 2</code>"},{"location":"operators/comparative/","title":"Comparative Operators","text":"Operator Description Example Result <code>==</code> Equal to <code>5 == 5</code> <code>true</code> <code>!=</code> Not equal to <code>5 != 3</code> <code>true</code> <code>&gt;</code> Greater than <code>7 &gt; 4</code> <code>true</code> <code>&lt;</code> Less than <code>3 &lt; 8</code> <code>true</code> <code>&gt;=</code> Greater than or equal to <code>6 &gt;= 6</code> <code>true</code> <code>&lt;=</code> Less than or equal to <code>2 &lt;= 5</code> <code>true</code>"},{"location":"operators/conditional/","title":"Conditional Operators","text":"Operator Description Example Result <code>? :</code> Ternary conditional (if-else) <code>x = (5 &gt; 3) ? \"yes\" : \"no\";</code> <code>\"yes\"</code>"},{"location":"operators/logical/","title":"Logical Operators","text":"Operator Description Example Result <code>&amp;&amp;</code> Logical AND <code>true &amp;&amp; false</code> <code>false</code> <code>||</code> Logical OR <code>true || false</code> <code>true</code> <code>!</code> Logical NOT <code>!true</code> <code>false</code>"}]}