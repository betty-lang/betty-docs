{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the Betty programming language documentation. Explore the language through examples, or dive into the comprehensive reference and understand the technical foundations.</p> <p>Warning</p> <p>This documentation is still a work in progress and may not cover all language features yet. Please check back for future updates!</p> <ul> <li> <p> Examples</p> <p>Practical examples demonstrating Betty's features and capabilities, from basic syntax to advanced programming concepts.</p> </li> <li> <p> Reference</p> <p>Comprehensive documentation of Betty's syntax, keywords, data types, and standard library functions.</p> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Note</p> <p>No binaries are currently supplied for the Betty interpreter. In the future, a GitHub Actions automated workflow for release builds is likely to be set up.</p> <p>Currently, the fastest way to get started with development in Betty is to clone the repo and build the binaries yourself.</p> <pre><code>git clone https://github.com/betty-lang/betty.git\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Explore practical examples demonstrating Betty's features and capabilities, from basic syntax to advanced programming concepts.</p> <ul> <li> <p> Expression Evaluator</p> <p>Implement a complete expression evaluator demonstrating parsing, evaluation, and advanced language features.</p> </li> </ul>"},{"location":"examples/expression-evaluator/","title":"Expression Evaluator","text":"<p>This is a mathematical expression evaluator implemented in Betty, showcasing the language\u2019s self-hosting (bootstrapping) potential.</p> <pre><code>### GLOBALS ###\n# Tokenizer\nglobal text;\nglobal pos;\nglobal currentChar;\n# Parser\nglobal tokens;\nglobal currentTokenIndex;\n### END GLOBALS ###\n\n### LEXER ###\n\nfunc advance()\n{\n    pos++;\n    if (pos &gt;= len(text))\n        currentChar = '\\0';\n    else\n        currentChar = text[pos];\n}\n\nfunc skipWhitespace()\n{\n    while (currentChar != '\\0' &amp;&amp; isspace(currentChar))\n        advance();\n}\n\nfunc initTokenizer(s)\n{\n    text = s;\n    pos = 0;\n    currentChar = text[pos];\n}\n\nfunc tokenize()\n{\n    # Initialize empty token list\n    tokList = [];\n    while (currentChar != '\\0')\n    {\n        if (isspace(currentChar))\n        {\n            skipWhitespace();\n            continue;\n        }\n        if (isdigit(currentChar))\n        {\n            number = \"\";\n            while (isdigit(currentChar))\n            {\n                number += tostr(currentChar);\n                advance();\n            }\n            tokList += [[\"Number\", tonum(number)]];\n            continue;\n        }\n        if (currentChar == '+'\n            || currentChar == '-'\n            || currentChar == '*'\n            || currentChar == '/') \n            {\n                tokList += [[\"BinOp\", currentChar]];\n                advance();\n                continue;\n            }\n        if (currentChar == '(' || currentChar == ')')\n        {\n            tokList += [[\"Paren\", currentChar]];\n            advance();\n            continue;\n        }\n        print(\"Error: Unrecognized character: \" + currentChar + \"\\n\");\n        break;\n    }\n    return tokList;\n}\n\n### END LEXER ###\n\n### PARSER ###\n\n# Initializes the parser with the tokens produced by the tokenizer\nfunc initParser(tokList)\n{\n    tokens = tokList;\n    currentTokenIndex = 0;\n}\n\n# Returns the current token without advancing\nfunc peekToken()\n{\n    if (currentTokenIndex &lt; len(tokens))\n        return tokens[currentTokenIndex];\n    return [\"EOF\", 0]; # End of tokens\n}\n\n# Returns the next token and advances the cursor\nfunc nextToken()\n{\n    token = peekToken();\n    if (token[0] != \"EOF\")\n        currentTokenIndex++;\n    return token;\n}\n\n# Parse a factor: a number or an expression in parentheses\nfunc parseFactor()\n{\n    token = nextToken();\n    if (token[0] == \"Number\") \n    {\n        return token[1]; # Return the numerical value\n    } \n    elif (token[0] == \"Paren\" &amp;&amp; token[1] == '(')\n    {\n        result = parseExpr(); # Parse the expression inside the parentheses\n        closingParen = nextToken();\n        if (closingParen[0] != \"Paren\" || closingParen[1] != ')')\n        {\n            println(\"Error: Expected ')'\");\n            return 0;\n        }\n        return result;\n    }\n    println(\"Error: Unexpected token in factor\");\n    return 0;\n}\n\n# Parse a term: a factor followed by '*' or '/' operators\nfunc parseTerm()\n{\n    result = parseFactor();\n    while (true)\n    {\n        token = peekToken();\n        if (token[0] == \"BinOp\" &amp;&amp; (token[1] == '*' || token[1] == '/'))\n        {\n            nextToken(); # Consume the operator\n            if (token[1] == '*')\n            {\n                result *= parseFactor();\n            }\n            elif (token[1] == '/')\n            {\n                result /= parseFactor();\n            }\n        }\n        else \n        {\n            break;\n        }\n    }\n    return result;\n}\n\n# Parse an expression: a term followed by '+' or '-' operators\nfunc parseExpr() \n{\n    result = parseTerm();\n    while (true) \n    {\n        token = peekToken();\n        if (token[0] == \"BinOp\" &amp;&amp; (token[1] == '+' || token[1] == '-'))\n        {\n            nextToken(); # Consume the operator\n            if (token[1] == '+') \n            {\n                result += parseTerm();\n            } \n            elif (token[1] == '-') \n            {\n                result -= parseTerm();\n            }\n        } \n        else \n        {\n            break;\n        }\n    }\n    return result;\n}\n\n# Main evaluation function that wraps the tokenizer and parser initialization and starts the parsing process\nfunc evaluate(expr) \n{\n    # Initialize the tokenizer\n    initTokenizer(expr);\n    # Tokenize the expression first\n    tokenList = tokenize();\n    # Initialize the parser with the token list\n    initParser(tokenList);\n    # Start parsing from the expression level\n    result = parseExpr();\n    println(\"Result: \", result);\n}\n\n### END PARSER ###\n\n# Entry point\nfunc main() \n{\n    while (true) \n    {\n        expr = input(\"&gt; \");\n        evaluate(expr);\n    }\n}\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<ul> <li> <p> Data Types</p> <p>Learn about Betty\u2019s built-in types such as <code>Number</code>, <code>String</code>, <code>Char</code>, <code>Boolean</code>, <code>List</code>, and <code>None</code>. Understand how they interact and convert implicitly during expression evaluation.</p> </li> <li> <p> Operators</p> <p>Explore arithmetic, logical, and comparative operators, as well as assignment and conditional operations. See how Betty handles precedence and implicit conversions.</p> </li> <li> <p> Keywords</p> <p>Reference all language keywords, including control flow structures, functions, and variable scope. </p> </li> <li> <p> Standard Library</p> <p>Discover Betty\u2019s intrinsic library functions for math, string manipulation, I/O, type conversion, and list operations.</p> </li> </ul> <p>To get started quickly, visit the Examples section or explore the Data Types reference.</p>"},{"location":"reference/data-types/","title":"Data Types","text":"<p>The Betty programming language provides a range of data types, each serving a unique purpose.  </p> <ul> <li> <p> Number</p> <p>Represents both integers and floating-point values, supporting arithmetic and implicit conversions. </p> </li> <li> <p> String </p> <p>A sequence of characters with intrinsic functions for manipulation and formatting.</p> </li> <li> <p> Char </p> <p>A single character, internally stored as an ASCII value, allowing seamless numeric operations. </p> </li> <li> <p> Boolean </p> <p>Represents truth values (<code>true</code> or <code>false</code>) and is used in logical operations and control flow. </p> </li> <li> <p> List </p> <p>A dynamic, ordered collection of values that can hold mixed data types and be manipulated efficiently. </p> </li> <li> <p> None </p> <p>A special type representing the absence of a value, often used for implicit returns.  </p> </li> </ul>"},{"location":"reference/data-types/boolean/","title":"Boolean","text":"<p>Boolean literals are represented with the <code>true</code> and <code>false</code> keywords, which are language-reserved and may not be used in another context. Logical operations in Betty require both operands to be of type <code>Boolean</code>. No implicit conversions between booleans and numeric values exist.</p> <pre><code>a = true;\n</code></pre>"},{"location":"reference/data-types/char/","title":"Char","text":"<p>Character literals are encased between a pair of single quotes ( <code>'</code> ). Empty character literals are not allowed in Betty programs. A character literal may not consist of more than one character, save for escape sequences\u2014which essentially are single characters.</p> <pre><code>x = 'b';    # Valid\nx = '\\n';   # Valid, escape sequence\nx = '';     # Will throw, empty character literal\nx = 'ab';   # Will throw, multi-character literal\nx = ';      # Will throw, unterminated character literal\n</code></pre> <p>Note</p> <p>Some operations between numbers and characters (character arithmetic) are handled implicitly by the interpreter, to an extent. Refer to the operator documentation syntax for further details, as well as to explore options for handling such operations explicitly.</p>"},{"location":"reference/data-types/list/","title":"List","text":"<p>Lists are currently the sole data structure of the Betty language, its bread and butter so to speak. Aided by the language's dynamic design, lists are very versatile in terms of their usage and what they can accomplish.</p> <p>Betty allows lists containing multiple data types, even different (nested) lists. Despite the lack of other data structures in the language, the flexibility achieved through this alone enables for \"custom\" record-like structures, even\u2014admittedly lesser-performing\u2014 maps.</p> <p>Note</p> <p>In the code examples section of the documentation, you can find a partial, preliminary attempt at bootstrapping (self-hosting) the Betty interpreter, showcasing the language's potential. Naturally, although such an implementation would result in less-than-ideal execution times, it is nonetheless a rather fun theoretical endeavor to take on.</p> <p>Betty is primarily a prototyping language, that much is certain. Be that as it may, the presence of lists\u2014along with some useful standard library functions, can assist the user in coding solutions to a multitude of problems. That was a major consideration in the way lists are implemented.</p> <p>One of the goals in the development process was to provide the programmer with ways to create something more meaningful than your typical \"Hello World,\" even at the cost of potential performance (the unavoidable tree-walk interpreter baggage). Whether they decide to \"get their hands dirty\" is ultimately left up to the user.</p> <pre><code>x = [1, 2, 3, 4];\nx = [1..5];             # Same declaration with range syntax\nx = [[1, 2], [3, 4]];   # Nested lists\n</code></pre>"},{"location":"reference/data-types/list/#string-indexing","title":"String indexing","text":"<p>Betty supports indexing strings and accessing them as character lists out-of-the-box, in alignment with the default behavior in various programming languages.</p> <pre><code>print(\"hello\"[1]); # Will print `e`\n</code></pre>"},{"location":"reference/data-types/none/","title":"None","text":"<p><code>None</code> is a special data type, in terms of how it works in Betty. It is not one of the language's keywords and neither variables nor functions can be assigned it. </p> <p>Nullability support can be a rather controversial topic among language designers, as including support for it could potentially lead to a plethora of runtime errors, like when dereferencing null pointers.</p> <p>What is more, extending a language to support null and nullable types can introduce a whole new layer of complexity (oftentimes unnecessary).</p> <p>However, allowing implicit returns of a <code>unit</code>-like value (<code>None</code>, in our case) can be beneficial in handling cases like the default return value of functions. Betty is a dynamic language, therefore a single function can return multiple data types. Introducing a default return value mitigates a significant class of potential issues and ensures all code paths have a return value.</p> <p>Under the hood, it is far more convenient to implement a visitor pattern in the interpreter, when all node visits result in the return of a uniform <code>Value</code> struct (with <code>None</code> as a potential value type). In this manner, there's no need for special handling of uninitialized or absent returns in dynamic typing contexts. It also avoids runtime surprises when a function unexpectedly fails to return a value.</p> <p>It should further be noted that since Betty allows expression-statements as first-class citizens, functions can be executed solely for their side effects and have their values discarded.</p> <pre><code>print(\"Hello, world!\"); # Valid, clearly intended for the side effect.\n</code></pre>"},{"location":"reference/data-types/number/","title":"Number","text":"<p>Betty uses a universal <code>number</code> data type to represent both integers and real numbers. Internally, all numeric values are stored as <code>double</code> for ease of handling. The language does, in fact, offer ways to work with strictly integer values, at least on the surface level, should one wish to do so.</p> <p>For instance, there are built-in math functions baked into the language for both <code>floor()</code> and <code>ceil()</code>. Additionally, there exists an integer division operator ( <code>//</code> ), which performs normal double division then floors the result, as is the case in several programming languages (e.g. Python, Ruby).</p> <pre><code>12\n0.5\n0.002\n-3\n</code></pre> <p>Under the hood, Betty leverages C#'s and, by extension, .NET's own <code>double</code> primitive value type, which means edge cases such as <code>infinity</code> and <code>NaN</code> are handled by the underlying framework implementation at the binary level.</p>"},{"location":"reference/data-types/string/","title":"String","text":"<p>Strings in Betty are enclosed between a pair of double quotes ( <code>\"</code> ). They are interned using a string lookup table so they can be lightweight\u2014in terms of memory overhead and allocations (on the stack vs. the heap), as well as be accessed very fast in ideal usage scenarios.</p> <pre><code>\"Hello, World!\";\n</code></pre> <p>In an addition operation, if either operand is a <code>string</code>, then the result is concatenated and returned as a <code>string</code>. This has been implemented to match the expected behavior in several programming languages.</p> <pre><code>\"Hi \" + 5; # Returns \"Hi 5\"\n</code></pre> <p>Furthermore, in addition to equality and inequality operations, strings allow comparisons like <code>&gt;</code> and <code>&lt;</code>, based on lexicographical order. This behavior may not always make intuitive sense to a newer programmer, nonetheless it is supported in plenty of programming languages. In the back-end, C#'s <code>CompareTo</code> standard library function (akin to <code>strcmp</code> in C) is utilized.</p> <pre><code>\"apple\" &lt; \"banana\"; # Returns `true`, since 'a' is less than 'b'\n</code></pre> <p>Compound (shorthand assignment) is supported in strings only through the addition ( <code>+</code> ) operator.</p>"},{"location":"reference/data-types/string/#escape-sequences","title":"Escape sequences","text":"Sequence Description <code>\\n</code> Newline <code>\\t</code> Tab <code>\\\"</code> Double quote <code>\\'</code> Single quote <code>\\\\</code> Backslash <code>\\0</code> Null character <p>Note</p> <p>Character literals also support the aforementioned sequences.</p>"},{"location":"reference/keywords/","title":"Keywords","text":"<p>Betty's reserved keywords form the foundation of the language, enabling control flow, function definitions, and variable management.</p> <ul> <li> <p> Control Flow</p> <p>Keywords for conditional execution and program flow control, including <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, and loop control statements.</p> </li> <li> <p> Functions</p> <p>Keywords for defining and working with functions, including <code>func</code>.</p> </li> <li> <p> Variables</p> <p>Keywords for variable and global variable declarations.</p> </li> </ul>"},{"location":"reference/keywords/control-flow/","title":"Control Flow","text":""},{"location":"reference/keywords/control-flow/#break-continue-return","title":"<code>break</code> / <code>continue</code> / <code>return</code>","text":"<p>These control flow keywords are an integral part of the C-like programming languages family (and many other families!).</p> <ul> <li><code>break</code>: Breaks out of a loop construct, resuming execution at the first statement after the loop's body.</li> <li><code>continue</code>: Prematurely ends the current iteration of a loop, jumping to the start of the next iteration.</li> <li><code>return</code>: Returns control of the program to a function's caller. If this statement is executed within a program's <code>main()</code> method, control is returned to the operating system, effectively terminating the program.</li> </ul>"},{"location":"reference/keywords/control-flow/#break-examples","title":"<code>break</code> Examples","text":"<pre><code># Breaking out of a while loop\ncounter = 0;\nwhile (true) {\n    counter = counter + 1;\n    if (counter == 5) {\n        break;\n    }\n}\n# counter = 5\n\n# Breaking out of a for loop\ncounter = 0;\nfor (i = 0; i &lt; 5; i = i + 1) {\n    counter = counter + 1;\n    if (counter == 3) {\n        break;\n    }\n}\n# counter = 3\n</code></pre>"},{"location":"reference/keywords/control-flow/#continue-examples","title":"<code>continue</code> Examples","text":"<pre><code># Continue in a while loop\ncounter = 0;\ni = 0;\nwhile (i &lt; 5) {\n    i = i + 1;\n    if (i == 2) {\n        continue;\n    }\n    counter = counter + 1;\n}\n# counter = 4 (skipped i == 2)\n\n# Continue in a for loop\ncounter = 0;\nfor (i = 0; i &lt; 5; i = i + 1) {\n    if (i == 2) {\n        continue;\n    }\n    counter = counter + 1;\n}\n# counter = 4\n\n# Continue in nested loops\ncounter = 0;\ni = 0;\nwhile (i &lt; 5) {\n    i = i + 1;\n    j = 0;\n    while (j &lt; 5) {\n        j = j + 1;\n        if (j == 3) {\n            continue;  # Continues inner loop only\n        }\n        counter = counter + 1;\n    }\n}\n# counter = 20\n</code></pre>"},{"location":"reference/keywords/control-flow/#return-examples","title":"<code>return</code> Examples","text":"<pre><code># Return from a function\nfunc add(a, b) {\n    return a + b;\n}\n\n# Early return from a loop\nfunc myfunc() {\n    counter = 0;\n    for (i = 0; i &lt; 5; i++) {\n        if (counter == 3) {\n            return counter;\n        }\n        counter = counter + 1;\n    }\n}\n# Returns 3\n\n# Return from main terminates the program\nfunc main() {\n    for (i = 0; i &lt; 5; i = i + 1) {\n        if (i == 3) {\n            return i;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#if-elif-else","title":"<code>if</code> / <code>elif</code> / <code>else</code>","text":"<p>Your standard issue, run-of-the-mill conditionals. <code>if</code> statements are used to execute a block of code, depending on whether a condition is true. An <code>if</code> statement can optionally be accompanied by a single or many <code>elif</code> statements, as well as an optional <code>else</code> statement at the end.</p> <p>This is what the complete structure looks like:</p> <pre><code>if (cond) {\n    # if-body\n}\nelif (elsecond) {\n    # elif-body\n}\nelse {\n    # else-body\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#basic-examples","title":"Basic Examples","text":"<pre><code># Simple if statement\nif (true) {\n    return 42;\n}\n\n# If-else statement\nif (false) {\n    return 42;\n}\nelse {\n    return 0;\n}\n\n# If-elif statement\nif (false) {\n    return 42;\n}\nelif (true) {\n    return 0;\n}\n\n# If-elif-else statement\nif (false) {\n    return 42;\n}\nelif (false) {\n    return 0;\n}\nelse {\n    return 1;\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#single-statement-form","title":"Single Statement Form","text":"<p>Single statements after conditionals don't require braces:</p> <pre><code>if (true) return 42;\n\nif (false) return 42;\nelse return 0;\n\nif (false) return 42;\nelif (true) return 0;\n</code></pre>"},{"location":"reference/keywords/control-flow/#nested-conditionals","title":"Nested Conditionals","text":"<pre><code>if (false) {\n    return 42;\n}\nelif (false) {\n    return 0;\n}\nelif (true) {\n    if (true) {\n        return 1;\n    }\n}\nelse {\n    return 2;\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#if-expressions","title":"If Expressions","text":"<p>Betty supports if expressions that return values and can be used in assignments:</p> <pre><code># Basic if expression\nx = if 1 == 1 then 2 else 6;\n# x = 2\n\n# If expression with elif\nx = if 1 == 2 then 2 elif 2 == 2 then 5 else 6;\n# x = 5\n\n# Multiple elif conditions\nx = if 1 == 2 then 2 elif 2 == 3 then 5 elif 4 == 4 then 7 else 6;\n# x = 7\n\n# Nested if expressions\nx = if 1 == 2 then 2 elif 2 == 2 then if 3 == 3 then 8 else 7 else 6;\n# x = 8\n</code></pre>"},{"location":"reference/keywords/control-flow/#ternary-operator","title":"Ternary Operator","text":"<p>Betty supports the ternary conditional operator <code>? :</code> for concise conditional expressions:</p> <pre><code># Basic ternary\nreturn true ? 1 : 0;  # Returns 1\n\n# False condition\nreturn false ? 1 : 2;  # Returns 2\n\n# Nested ternary\nreturn (true ? false : true) ? 1 : 2;  # Returns 2\n\n# With arithmetic expressions\nreturn (1 + 1 == 2) ? (3 * 2) : (4 / 2);  # Returns 6\n\n# Within arithmetic expressions\nreturn 10 + (false ? 100 : 200) * 2;  # Returns 410\n\n# Complex nested ternary\nreturn (5 &gt; 3 ? 3 &lt; 2 : 4 &gt; 2) ? (7 == 7 ? 9 : 8) : (6 == 6 ? 10 : 11);\n# Returns 10\n\n# With function calls\nreturn (2 == 2) ? add(4, 5) : multiply(3, 3);  # Returns 9\n</code></pre>"},{"location":"reference/keywords/control-flow/#switch-statements-and-expressions","title":"Switch Statements and Expressions","text":"<p>Betty supports two forms of switch constructs: traditional switch statements for control flow, and switch expressions for value-returning pattern matching.</p>"},{"location":"reference/keywords/control-flow/#switch-expressions","title":"Switch Expressions","text":"<p>Switch expressions use a concise syntax that evaluates to a value, making them ideal for assignments and inline usage. The syntax follows the pattern <code>value switch { pattern =&gt; result, ... }</code>.</p>"},{"location":"reference/keywords/control-flow/#basic-syntax","title":"Basic Syntax","text":"<pre><code>value switch {\n    pattern1 =&gt; result1,\n    pattern2 =&gt; result2,\n    _ =&gt; defaultResult\n}\n</code></pre> <p>The <code>_</code> (underscore) acts as a default case, matching any value that doesn't match previous patterns.</p>"},{"location":"reference/keywords/control-flow/#basic-examples_1","title":"Basic Examples","text":"<pre><code># Simple value matching\nx = 2;\nresult = x switch {\n    1 =&gt; \"One\",\n    2 =&gt; \"Two\",\n    3 =&gt; \"Three\",\n    _ =&gt; \"Other\"\n};\n# result = \"Two\"\n\n# Numeric results\ngrade = 'B';\npoints = grade switch {\n    'A' =&gt; 4,\n    'B' =&gt; 3,\n    'C' =&gt; 2,\n    'D' =&gt; 1,\n    _ =&gt; 0\n};\n# points = 3\n\n# String matching\nday = \"Monday\";\ntype = day switch {\n    \"Monday\" =&gt; \"Weekday\",\n    \"Tuesday\" =&gt; \"Weekday\",\n    \"Saturday\" =&gt; \"Weekend\",\n    \"Sunday\" =&gt; \"Weekend\",\n    _ =&gt; \"Unknown\"\n};\n# type = \"Weekday\"\n\n# Boolean conditions\nisActive = true;\nstatus = isActive switch {\n    true =&gt; \"Active\",\n    false =&gt; \"Inactive\"\n};\n# status = \"Active\"\n</code></pre>"},{"location":"reference/keywords/control-flow/#switch-after-function-calls","title":"Switch After Function Calls","text":"<p>Switch expressions can be applied directly to the result of a function call:</p> <pre><code>func getValue() { return 3; }\n\nresult = getValue() switch {\n    1 =&gt; \"One\",\n    2 =&gt; \"Two\",\n    3 =&gt; \"Three\",\n    _ =&gt; \"Other\"\n};\n# result = \"Three\"\n</code></pre>"},{"location":"reference/keywords/control-flow/#switch-in-expressions","title":"Switch in Expressions","text":"<p>Switch expressions can be used anywhere an expression is expected:</p> <pre><code># In function arguments\nfunc double(n) { return n * 2; }\nx = 5;\nresult = double(x switch {\n    5 =&gt; 10,\n    10 =&gt; 20,\n    _ =&gt; 0\n});\n# result = 20\n\n# In indexer operations\narr = [\"zero\", \"one\", \"two\"];\nx = 1;\nresult = arr[x switch {\n    0 =&gt; 0,\n    1 =&gt; 1,\n    2 =&gt; 2,\n    _ =&gt; 0\n}];\n# result = \"one\"\n\n# In binary expressions\nx = 2;\nresult = (x switch {\n    1 =&gt; 10,\n    2 =&gt; 20,\n    _ =&gt; 0\n}) + 5;\n# result = 25\n</code></pre>"},{"location":"reference/keywords/control-flow/#nested-switch-expressions","title":"Nested Switch Expressions","text":"<p>Switch expressions can be nested within other switch expressions:</p> <pre><code>x = 1;\ny = 2;\nresult = x switch {\n    1 =&gt; y switch {\n        1 =&gt; \"One-One\",\n        2 =&gt; \"One-Two\",\n        _ =&gt; \"One-Other\"\n    },\n    2 =&gt; \"Two\",\n    _ =&gt; \"Other\"\n};\n# result = \"One-Two\"\n</code></pre>"},{"location":"reference/keywords/control-flow/#switch-with-lambda-functions","title":"Switch with Lambda Functions","text":"<p>Switch expressions work seamlessly with lambda functions, making them powerful for functional programming patterns:</p> <pre><code># Returning different lambdas\nmode = 2;\ncalculator = mode switch {\n    1 =&gt; func(a, b) { return a + b; },\n    2 =&gt; func(a, b) { return a * b; },\n    3 =&gt; func(a, b) { return a - b; },\n    _ =&gt; func(a, b) { return 0; }\n};\nresult = calculator(7, 3);\n# result = 21\n\n# With closure capture\nmultiplier = 10;\ntype = \"add\";\noperation = type switch {\n    \"add\" =&gt; func(x) { return x + multiplier; },\n    \"multiply\" =&gt; func(x) { return x * multiplier; },\n    _ =&gt; func(x) { return x; }\n};\nresult = operation(5);\n# result = 15\n\n# Returning list of lambdas\ntype = \"math\";\noperations = type switch {\n    \"math\" =&gt; [\n        func(x) { return x + 1; },\n        func(x) { return x * 2; }\n    ],\n    \"string\" =&gt; [\n        func(x) { return x; }\n    ],\n    _ =&gt; []\n};\nresult = operations[0](5) + operations[1](3);\n# result = 12 (6 + 6)\n\n# Matching on lambda equality\nfn1 = func() { return 1; };\nfn2 = func() { return 2; };\ntarget = fn1;\n\nresult = target switch {\n    fn1 =&gt; \"First function\",\n    fn2 =&gt; \"Second function\",\n    _ =&gt; \"Unknown function\"\n};\n# result = \"First function\"\n</code></pre>"},{"location":"reference/keywords/control-flow/#switch-statements","title":"Switch Statements","text":"<p>Traditional C-style switch statements provide control flow with explicit fall-through behavior. Unlike many languages, Betty requires explicit <code>break</code> statements to prevent fall-through.</p>"},{"location":"reference/keywords/control-flow/#basic-syntax_1","title":"Basic Syntax","text":"<pre><code>switch (expression) {\n    case value1:\n        # statements\n        break;\n    case value2:\n        # statements\n        break;\n    default:\n        # statements\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#basic-examples_2","title":"Basic Examples","text":"<pre><code># Simple switch with breaks\nx = 2;\nswitch (x) {\n    case 1:\n        return 10;\n    case 2:\n        return 20;\n    case 3:\n        return 30;\n    default:\n        return 40;\n}\n# Returns 20\n\n# Switch with default case\nx = 5;\nswitch (x) {\n    case 1:\n        return 10;\n    case 2:\n        return 20;\n    default:\n        return 40;\n}\n# Returns 40\n</code></pre>"},{"location":"reference/keywords/control-flow/#fall-through-behavior","title":"Fall-Through Behavior","text":"<p>Without a <code>break</code> statement, execution continues into the next case:</p> <pre><code>x = 1;\nswitch (x) {\n    case 1:\n        x = 2;\n        # no break - falls through\n    case 2:\n        x = 3;\n        # no break - falls through\n    case 3:\n        x = 4;\n    default:\n        x = 100;\n}\n# x = 100 (all cases executed)\n\n# With break statements\nx = 1;\nswitch (x) {\n    case 1:\n        x = 2;\n        break;\n    case 2:\n        x = 3;\n        break;\n    case 3:\n        x = 4;\n        break;\n    default:\n        x = 100;\n}\n# x = 2 (only first case executed)\n</code></pre>"},{"location":"reference/keywords/control-flow/#scoped-case-bodies","title":"Scoped Case Bodies","text":"<p>Case bodies can be wrapped in braces to create a local scope:</p> <pre><code># Braced case with local scope\nx = 1;\nresult = 0;\nswitch (x) {\n    case 1: {\n        temp = 100;\n        result = temp;\n        break;\n    }\n    case 2: {\n        temp = 200;\n        result = temp;\n        break;\n    }\n}\n# result = 100\n\n# Mixed braced and unbraced cases\nx = 2;\nresult = 0;\nswitch (x) {\n    case 1:\n        result = 10;\n        break;\n    case 2: {\n        temp = 15;\n        result = temp + 5;\n        break;\n    }\n    case 3:\n        result = 30;\n        break;\n}\n# result = 20\n</code></pre>"},{"location":"reference/keywords/control-flow/#fall-through-with-shared-scope","title":"Fall-Through with Shared Scope","text":"<p>When cases fall through without braces, they share the same scope:</p> <pre><code>x = 1;\nresult = 0;\nswitch (x) {\n    case 1:\n        temp = 50;\n        # no break - falls through\n    case 2:\n        result = temp + 10;  # Uses temp from case 1\n        break;\n}\n# result = 60\n</code></pre> <p>Warning</p> <p>Switch statements in Betty do not automatically break after each case. You must explicitly use <code>break</code> to prevent fall-through to the next case. This behavior matches C-style switch statements and allows for intentional fall-through patterns.</p> <p>Note</p> <p>Switch expressions are typically preferred over switch statements when you need to return a value, as they are more concise and expression-oriented. Use switch statements when you need complex control flow with multiple statements per case or when you want to leverage fall-through behavior.</p>"},{"location":"reference/keywords/control-flow/#for-foreach","title":"<code>for</code> / <code>foreach</code>","text":"<p>Although a language can do fine with just a while loop, for (and for-each) loops are a staple in C-like languages.</p>"},{"location":"reference/keywords/control-flow/#for-loop","title":"For Loop","text":"<pre><code>for (initializer; condition; increment) {\n    # body\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#basic-for-loop","title":"Basic For Loop","text":"<pre><code>counter = 0;\nfor (i = 0; i &lt; 5; i = i + 1) {\n    counter = counter + 1;\n}\n# counter = 5\n</code></pre>"},{"location":"reference/keywords/control-flow/#for-loop-with-shorthand-increment","title":"For Loop with Shorthand Increment","text":"<pre><code>counter = 0;\nfor (i = 0; i &lt; 5; i++) {\n    counter = counter + 1;\n}\n# counter = 5\n</code></pre>"},{"location":"reference/keywords/control-flow/#empty-components","title":"Empty Components","text":"<p>Betty allows you to omit any or all components of a for loop:</p> <pre><code># Empty initializer\ncounter = 0;\nfor (; counter &lt; 5; counter = counter + 1) {\n    counter = counter + 1;\n}\n\n# Empty increment\ncounter = 0;\nfor (i = 0; i &lt; 5; ) {\n    counter = counter + 1;\n    i = i + 1;\n}\n\n# Empty condition (creates infinite loop, use with break)\ncounter = 0;\nfor (i = 0; ; i = i + 1) {\n    counter = counter + 1;\n    if (counter == 5) {\n        break;\n    }\n}\n\n# All empty (infinite loop)\ncounter = 0;\nfor (; ; ) {\n    counter = counter + 1;\n    if (counter == 5) {\n        break;\n    }\n}\n</code></pre> <p>Note</p> <p>In Betty, you may create a <code>for</code> loop without an initializer, condition or increment expression, or any other combination. This behavior closely aligns with how <code>for</code> loops work in many programming languages and was implemented in this manner for consistency purposes. Thus, <code>for (; ;)</code> can be used to create a non-terminating loop.</p>"},{"location":"reference/keywords/control-flow/#for-each-loop","title":"For-Each Loop","text":"<p>The for-each loop uses the <code>in</code> keyword, expecting an iterable expression (like a list) after it.</p> <pre><code>foreach (variableName in iterable) {\n    # body\n}\n</code></pre> <p>For-each loops can additionally be used to iterate through ranges and strings.</p>"},{"location":"reference/keywords/control-flow/#range-iteration","title":"Range Iteration","text":"<pre><code>foreach (i in [1..5]) {\n    println(i);     # Prints the numbers 1 to 4\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#string-iteration","title":"String Iteration","text":"<pre><code>s = \"Hello, World!\";\nforeach (c in s) {\n    println(c);     # Prints each character in the string\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#while-do-while","title":"<code>while</code> / <code>do while</code>","text":"<p>While and do-while loops in Betty use standard syntax.</p>"},{"location":"reference/keywords/control-flow/#while-loop","title":"While Loop","text":"<pre><code>while (condition) {\n    # body\n}\n</code></pre>"},{"location":"reference/keywords/control-flow/#do-while-loop","title":"Do-While Loop","text":"<pre><code>do {\n    # body\n} while (cond)\n</code></pre> <p>Note</p> <p>The body of any construct in Betty can either be a single statement or a compound statement (list of statements). In the case of singular statements, braces ( <code>{</code> <code>}</code> ) are not required. It is recommended that you use proper indentation and spacing to distinguish such statements from the statements succeeding them, ensuring code readability, should you choose to make use of this feature.</p>"},{"location":"reference/keywords/functions/","title":"Functions","text":"<p>The <code>func</code> keyword is used to begin a function definition. Functions in Betty are defined at the root level.</p> <pre><code>func foo(param1, param2, ... , paramn)\n{\n    # body\n}\n</code></pre> <p>Empty function definitions are valid in Betty, however duplicate definitions are not. Function overloading is not supported at this moment.</p> <p>Every Betty program requires a <code>main()</code> function as an entry point. If the interpreter does not find one, an error will be raised. Intrinsic function (standard library) function names are reserved and cannot be overridden. For a comprehensive list of all built-in functions, refer to the Standard Library.</p> <p>Note</p> <p>Due to the dynamic nature of the Betty language, different code paths are allowed to return different data types. All functions, when in a code path where a return statement is omitted, implicitly return to the caller the unit-like value <code>None</code>, Betty's \"secret\" type. Refer to the <code>None</code> data type documentation for details.</p>"},{"location":"reference/keywords/functions/#recursion","title":"Recursion","text":"<p>Functions in Betty support recursion, allowing a function to call itself:</p> <pre><code>func fact(n) {\n    if (n &lt;= 1) { return 1; }\n    return n * fact(n - 1);\n}\n\nfunc main() {\n    return fact(5); # Returns 120\n}\n</code></pre>"},{"location":"reference/keywords/functions/#lambdas","title":"Lambdas","text":"<p>Lambda functions (also called function expressions or anonymous functions) can be created using the <code>func</code> keyword without a name. These can be assigned to variables, passed as arguments, stored in data structures, or called immediately.</p>"},{"location":"reference/keywords/functions/#basic-lambda-assignment","title":"Basic Lambda Assignment","text":"<pre><code>func main() {\n    greet = func() { return \"Hello\"; };\n    return greet(); # Returns \"Hello\"\n}\n</code></pre>"},{"location":"reference/keywords/functions/#lambdas-with-parameters","title":"Lambdas with Parameters","text":"<p>Lambda functions can accept parameters just like regular functions:</p> <pre><code>func main() {\n    add = func(a, b) { return a + b; };\n    return add(2, 3); # Returns 5\n}\n</code></pre>"},{"location":"reference/keywords/functions/#closures","title":"Closures","text":"<p>Lambda functions can capture variables from their surrounding scope, creating closures:</p> <pre><code>func main() {\n    x = 10;\n    multiply = func(y) { return x * y; };\n    return multiply(3); # Returns 30\n}\n</code></pre>"},{"location":"reference/keywords/functions/#recursive-lambdas","title":"Recursive Lambdas","text":"<p>Lambda functions can be recursive by referencing their assigned variable name:</p> <pre><code>func main() {\n    fact = func(n) {\n        if (n &lt;= 1) { return 1; }\n        return n * fact(n - 1);\n    };\n    return fact(5); # Returns 120\n}\n</code></pre>"},{"location":"reference/keywords/functions/#nested-lambdas","title":"Nested Lambdas","text":"<p>Lambda functions can be nested within other lambdas:</p> <pre><code>func main() {\n    outer = func() {\n        inner = func() { return 42; };\n        return inner();\n    };\n    return outer(); # Returns 42\n}\n</code></pre>"},{"location":"reference/keywords/functions/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Lambda functions can be passed as arguments to other functions:</p> <pre><code>func main() {\n    apply = func(fn, value) { return fn(value); };\n    square = func(x) { return x * x; };\n    return apply(square, 4); # Returns 16\n}\n</code></pre>"},{"location":"reference/keywords/functions/#immediately-invoked-lambda-expressions","title":"Immediately Invoked Lambda Expressions","text":"<p>Lambda functions can be called immediately upon creation:</p> <pre><code>func main() {\n    return (func() { return 42; })(); # Returns 42\n}\n</code></pre>"},{"location":"reference/keywords/functions/#lambdas-in-data-structures","title":"Lambdas in Data Structures","text":"<p>Function expressions can be stored in lists and other data structures:</p> <pre><code>func main() {\n    funcs = [\n        func(x) { return x + 1; },\n        func(x) { return x * 2; }\n    ];\n\n    result1 = funcs[0](3); # Returns 4\n    result2 = funcs[1](3); # Returns 6\n\n    return result1 + result2; # Returns 10\n}\n</code></pre>"},{"location":"reference/keywords/functions/#function-reference-equality","title":"Function Reference Equality","text":"<p>Function references are compared by identity. Two variables pointing to the same function are equal, but two separately defined functions (even with identical implementations) are not:</p> <pre><code>func main() {\n    greet1 = func() { return \"Hello\"; };\n    greet2 = greet1; # Same reference\n    greet3 = func() { return \"Hello\"; }; # Different function\n\n    greet1 == greet2; # true - same reference\n    greet1 == greet3; # false - different functions\n}\n</code></pre>"},{"location":"reference/keywords/functions/#local-named-functions","title":"Local Named Functions","text":"<p>While the statement \"functions are defined at the root level\" applies to globally accessible functions, Betty also supports defining named functions locally within other functions and blocks. These local named functions use the same <code>func name() { }</code> syntax as global functions but have limited scope visibility.</p>"},{"location":"reference/keywords/functions/#basic-local-functions","title":"Basic Local Functions","text":"<p>Local named functions can be defined inside any function or block:</p> <pre><code>func main() {\n    func greet() { return \"Hello\"; }\n    return greet(); # Returns \"Hello\"\n}\n</code></pre>"},{"location":"reference/keywords/functions/#local-functions-with-parameters","title":"Local Functions with Parameters","text":"<p>Like global functions, local functions can accept parameters:</p> <pre><code>func main() {\n    func add(a, b) { return a + b; }\n    return add(2, 3); # Returns 5\n}\n</code></pre>"},{"location":"reference/keywords/functions/#closures-read-only","title":"Closures (Read-Only)","text":"<p>Local named functions can capture variables from their enclosing scope, creating closures. However, closures in Betty are currently read-only - captured variables can be read but not modified:</p> <pre><code>func main() {\n    x = 10;\n    func multiply(y) { return x * y; }\n    return multiply(3); # Returns 30\n}\n</code></pre> <pre><code>func main() {\n    a = 5;\n    b = 10;\n    func compute() {\n        c = 15;\n        return a + b + c; # Can read a and b from outer scope\n    }\n    return compute(); # Returns 30\n}\n</code></pre> <p>Warning</p> <p>Closures in Betty are read-only. Local functions can read variables from enclosing scopes but cannot modify them. Attempting to assign to a captured variable will create a new local variable instead of modifying the outer one.</p>"},{"location":"reference/keywords/functions/#recursive-local-functions","title":"Recursive Local Functions","text":"<p>Local named functions can call themselves recursively:</p> <pre><code>func main() {\n    func fact(n) {\n        if (n &lt;= 1) { return 1; }\n        return n * fact(n - 1);\n    }\n    return fact(5); # Returns 120\n}\n</code></pre>"},{"location":"reference/keywords/functions/#nested-local-functions","title":"Nested Local Functions","text":"<p>Local functions can be nested within other local functions:</p> <pre><code>func main() {\n    func outer() {\n        func inner() { return 42; }\n        return inner();\n    }\n    return outer(); # Returns 42\n}\n</code></pre>"},{"location":"reference/keywords/functions/#function-shadowing","title":"Function Shadowing","text":"<p>Local functions can shadow global functions or other local functions in outer scopes:</p> <pre><code># Shadowing global functions\nfunc getValue() { return 100; }\nfunc main() {\n    func getValue() { return 200; }\n    return getValue(); # Returns 200\n}\n</code></pre> <pre><code># Shadowing in nested blocks\nfunc main() {\n    func getValue() { return 10; }\n    x = getValue();\n    {\n        func getValue() { return 20; }\n        x = x + getValue();\n    }\n    x = x + getValue();\n    return x; # Returns 40 (10 + 20 + 10)\n}\n</code></pre> <p>When a shadowed function goes out of scope, the outer function becomes accessible again:</p> <pre><code>func getValue() { return 100; }\nfunc main() {\n    outer = getValue();\n    {\n        func getValue() { return 200; }\n        inner = getValue();\n    }\n    after = getValue();\n    return outer + after; # Returns 200 (100 + 100)\n}\n</code></pre>"},{"location":"reference/keywords/functions/#block-level-scoping","title":"Block-Level Scoping","text":"<p>Local functions defined in different blocks can have the same name without conflict:</p> <pre><code>func main() {\n    result = 0;\n    {\n        func addOne() { return 1; }\n        result = result + addOne();\n    }\n    {\n        func addOne() { return 10; }\n        result = result + addOne();\n    }\n    return result; # Returns 11 (0 + 1 + 10)\n}\n</code></pre>"},{"location":"reference/keywords/functions/#returning-local-functions","title":"Returning Local Functions","text":"<p>Local functions can return other local functions, creating closure factories:</p> <pre><code>func main() {\n    func makeAdder(x) {\n        func adder(y) { return x + y; }\n        return adder;\n    }\n    add5 = makeAdder(5);\n    return add5(10); # Returns 15\n}\n</code></pre> <p>Each returned function captures its own copy of the closure variables:</p> <pre><code>func main() {\n    func makeMultiplier(factor) {\n        func multiply(n) { return n * factor; }\n        return multiply;\n    }\n    double = makeMultiplier(2);\n    triple = makeMultiplier(3);\n    return double(5) + triple(5); # Returns 25 ((5*2) + (5*3))\n}\n</code></pre>"},{"location":"reference/keywords/functions/#assigning-to-variables","title":"Assigning to Variables","text":"<p>Local named functions can be assigned to variables, just like lambdas:</p> <pre><code>func main() {\n    func greet() { return \"Hello\"; }\n    fn = greet;\n    return fn(); # Returns \"Hello\"\n}\n</code></pre>"},{"location":"reference/keywords/functions/#calling-between-local-functions","title":"Calling Between Local Functions","text":"<p>Local functions can call other local functions defined in the same scope:</p> <pre><code>func main() {\n    func add(a, b) { return a + b; }\n    func addAndDouble(a, b) { return add(a, b) * 2; }\n    return addAndDouble(3, 4); # Returns 14\n}\n</code></pre>"},{"location":"reference/keywords/functions/#passing-as-arguments","title":"Passing as Arguments","text":"<p>Local functions can be passed as arguments to other functions:</p> <pre><code>func main() {\n    func apply(fn, value) { return fn(value); }\n    func square(x) { return x * x; }\n    return apply(square, 4); # Returns 16\n}\n</code></pre>"},{"location":"reference/keywords/functions/#mixed-with-lambdas","title":"Mixed with Lambdas","text":"<p>Local named functions and lambda expressions can be used together seamlessly:</p> <pre><code>func main() {\n    func named(x) { return x + 1; }\n    lambda = func(x) { return x * 2; };\n    return named(5) + lambda(5); # Returns 16 (6 + 10)\n}\n</code></pre> <p>Note</p> <p>The primary difference between local named functions (<code>func name() { }</code>) and lambda expressions (<code>name = func() { }</code>) is syntactic. Both create first-class function values that can be passed around, assigned to variables, and used in closures. Choose local named functions for clarity when defining helper functions within a scope, and lambdas when you need to create function values inline or store them in data structures.</p>"},{"location":"reference/keywords/variables/","title":"Variables","text":""},{"location":"reference/keywords/variables/#variable-assignment","title":"Variable Assignment","text":"<p>Variables in Betty are dynamically typed and do not require explicit type declarations. A variable is created simply by assigning a value to it:</p> <pre><code>x = 5;              # Number variable\nname = \"Alice\";     # String variable\nflag = true;        # Boolean variable\nmylist = [1, 2, 3]; # List variable\n</code></pre>"},{"location":"reference/keywords/variables/#assignment-with-expressions","title":"Assignment with Expressions","text":"<p>Variables can be assigned the result of any expression:</p> <pre><code>x = 2 + 3;          # x = 5\ny = x * 2;          # y = 10\nz = foo();          # z = return value of foo()\n</code></pre>"},{"location":"reference/keywords/variables/#chain-assignment","title":"Chain Assignment","text":"<p>Multiple variables can be assigned the same value in a single statement:</p> <pre><code>x = y = 5;          # Both x and y are assigned 5\na = b = c = 10;     # Multiple chain assignment\n</code></pre>"},{"location":"reference/keywords/variables/#global-variables","title":"Global Variables","text":"<p>The <code>global</code> keyword is used to declare a global, program-wide variable. Global variable declarations in Betty are top-level statements. Global variables cannot be assigned to on declaration. They can be declared anywhere in the code's root  level, nonetheless it is encouraged to declare them at the start of the program.</p> <p>The decision to include global variables in a programming language can admittedly be rather controversial, as such a design strays away from pure and clean programming practices. Care should be exercised, as careless usage of globals can be headache-inducing.</p> <p>That being said, Betty's syntax for global variables is very straightforward.</p> <pre><code>global x;           # Declares 'x' as a global variable\n\nfunc side_effect()\n{\n    x = 10;\n}\n\nfunc main()\n{\n    x = 2;\n    side_effect();\n    print(x);       # Will print '10'\n}\n</code></pre>"},{"location":"reference/keywords/variables/#scope-and-shadowing","title":"Scope and Shadowing","text":"<p>Global variables can be shadowed by function parameters. When a function parameter has the same name as a global variable, the parameter takes precedence within that function's scope, leaving the global variable unchanged:</p> <pre><code>global x;\n\nfunc foo(x) {\n    x = 4;          # Modifies the parameter, not the global\n}\n\nfunc main() {\n    x = 5;          # Sets global x to 5\n    foo(3);         # Parameter x shadows global x\n    print(x);       # Prints '5' - global x is unchanged\n}\n</code></pre>"},{"location":"reference/keywords/variables/#access-across-functions","title":"Access Across Functions","text":"<p>Global variables can be accessed and modified by any function in the program:</p> <pre><code>global x;\n\nfunc main() {\n    x = 5;          # Sets global x to 5\n    other();        # Calls other(), which modifies x\n    print(x);       # Prints '3' - x was modified by other()\n}\n\nfunc other() {\n    x = 3;          # Modifies the global x\n}\n</code></pre>"},{"location":"reference/operators/","title":"Operators","text":"<p>Operators in Betty provide powerful ways to perform calculations, compare values, and control execution flow.  </p> <ul> <li> <p> Arithmetic </p> <p>Perform fundamental mathematical operations like addition, subtraction, multiplication, and division.  </p> </li> <li> <p> Logical </p> <p>Combine boolean values and control decision-making with AND, OR, and NOT operations.</p> </li> <li> <p> Comparative </p> <p>Compare numbers, strings, and other data types to determine equality, order, and differences.</p> </li> <li> <p> Conditional</p> <p>Use the ternary operator to make concise, inline decisions based on conditions.</p> </li> <li> <p> Assignment </p> <p>Assign values to variables and modify them efficiently with compound assignment operators.</p> </li> <li> <p> Special </p> <p>Work with unique syntax features like ranges and list indexing for efficient data handling.</p> </li> </ul>"},{"location":"reference/operators/arithmetic/","title":"Arithmetic Operators","text":"Operator Description Example <code>+</code> Addition <code>1 + 2</code> \u2192 <code>3</code> <code>-</code> Subtraction <code>5 - 3</code> \u2192 <code>2</code> <code>*</code> Multiplication <code>4 * 2</code> \u2192 <code>8</code> <code>/</code> Division <code>8 / 2</code> \u2192 <code>4</code> <code>%</code> Modulus <code>10 % 3</code> \u2192 <code>1</code> <code>^</code> Exponentiation <code>2 ^ 3</code> \u2192 <code>8</code> <code>//</code> Floor Division <code>7 // 2</code> \u2192 <code>3</code>"},{"location":"reference/operators/arithmetic/#addition-overloads","title":"Addition overloads","text":""},{"location":"reference/operators/arithmetic/#string-concatenation","title":"String concatenation","text":"<p>The addition operator has been overloaded to support string concatenation. Therefore, syntax such as <code>\"Hello \" + \"World\"</code> is possible in Betty.</p> <p>Note</p> <p>String concatenation is also supported through an appropriately-named <code>concat()</code> built-in language function, as well as the <code>print()</code> function itself. Further examples of string manipulation can be found in the intrinsic functions documentation.</p>"},{"location":"reference/operators/arithmetic/#list-operand-addition","title":"List-operand addition","text":"<p>If either operand of an addition operation is a <code>list</code>, the interpreter will append the other operand to it\u2014either at the beginning or the end, depending on the operand order. If both operands are lists, the second list will be appended to the end of the first.</p> <p>Since lists are reference types in Betty, this operation modifies the original list rather than creating a new one.</p> <p>Cases:</p> <ul> <li><code>list + element</code> would append <code>element</code> to the end of <code>list</code>.</li> <li><code>element + list</code> would prepend <code>element</code> to the beginning of <code>list</code>.</li> <li><code>list1 + list2</code> would append <code>list2</code> to <code>list1</code>, modifying <code>list1</code>.</li> </ul> <p>Example:</p> <pre><code>a = \"hello\";\nb = [1, 2];\nreturn b + a; # Will append the string to the end of `b`, i.e. [1, 2, \"hello\"]\n</code></pre>"},{"location":"reference/operators/arithmetic/#implicit-conversions","title":"Implicit conversions","text":"<p>For the sake of convenience and flexibility, Betty will handle some common scenarios implicitly, as far as the expected outcome of \"adding\" different data types is concerned. For those who prefer boldness and completeness over simplicity\u2014although type hinting is not a feature\u2014the language constructs do allow you to explicitly specify most conversion operations.</p>"},{"location":"reference/operators/arithmetic/#character-arithmetic","title":"Character arithmetic","text":"<p>In Betty, characters are implicitly converted to their ASCII values when used in arithmetic operations. This allows direct manipulation of characters as numeric values.</p> <pre><code>charValue = 'a';\ncharValue += 1;         # Implicitly converts 'a' to its ASCII value, then increments\nprint(charValue);       # Outputs the number corresponding to 'b' in ASCII\nnumberValue = 10;\nnumberValue += '3';     # '3' is implicitly converted to its numeric ASCII value before addition\nprint(numberValue);     # Outputs the result of the addition\n</code></pre> <p>Note</p> <p>As types in Betty are, for the most part, not strictly enforced, the interpreter will automatically handle conversions like these to reduce friction and boilerplate code.</p> <p>Warning</p> <p>In order to avoid confusion and ensure clarity, an explicit conversion back to <code>char</code> would be needed in order to print the character representations in the example.</p>"},{"location":"reference/operators/assignment/","title":"Assignment Operators","text":"Operator Description Example Equivalent To <code>=</code> Assign value <code>x = 5</code> <code>x = 5</code>"},{"location":"reference/operators/assignment/#compound-assignment","title":"Compound assignment","text":"Operator Description Example Equivalent To <code>+=</code> Add and assign <code>x += 3</code> <code>x = x + 3</code> <code>-=</code> Subtract and assign <code>x -= 2</code> <code>x = x - 2</code> <code>*=</code> Multiply and assign <code>x *= 4</code> <code>x = x * 4</code> <code>/=</code> Divide and assign <code>x /= 2</code> <code>x = x / 2</code> <code>%=</code> Modulus and assign <code>x %= 3</code> <code>x = x % 3</code> <code>^=</code> Exponentiate and assign <code>x ^= 2</code> <code>x = x ^ 2</code> <code>//=</code> Floor divide and assign <code>x //= 2</code> <code>x = x // 2</code>"},{"location":"reference/operators/assignment/#prefix-postfix-incrementdecrement","title":"Prefix &amp; postfix increment/decrement","text":"Operator Type Description Example Result <code>++x</code> Prefix Increments <code>x</code> before evaluation <code>x = 5; y = ++x;</code> <code>x = 6, y = 6</code> <code>x++</code> Postfix Increments <code>x</code> after evaluation <code>x = 5; y = x++;</code> <code>x = 6, y = 5</code> <code>--x</code> Prefix Decrements <code>x</code> before evaluation <code>x = 5; y = --x;</code> <code>x = 4, y = 4</code> <code>x--</code> Postfix Decrements <code>x</code> after evaluation <code>x = 5; y = x--;</code> <code>x = 4, y = 5</code>"},{"location":"reference/operators/comparative/","title":"Comparative Operators","text":"Operator Description Example Result <code>==</code> Equal to <code>5 == 5</code> <code>true</code> <code>!=</code> Not equal to <code>5 != 3</code> <code>true</code> <code>&gt;</code> Greater than <code>7 &gt; 4</code> <code>true</code> <code>&lt;</code> Less than <code>3 &lt; 8</code> <code>true</code> <code>&gt;=</code> Greater than or equal to <code>6 &gt;= 6</code> <code>true</code> <code>&lt;=</code> Less than or equal to <code>2 &lt;= 5</code> <code>true</code>"},{"location":"reference/operators/conditional/","title":"Conditional Operators","text":"Operator Description Example Result <code>? :</code> Ternary conditional (if-else) <code>x = (5 &gt; 3) ? \"yes\" : \"no\";</code> <code>\"yes\"</code>"},{"location":"reference/operators/logical/","title":"Logical Operators","text":"Operator Description Example Result <code>&amp;&amp;</code> Logical AND <code>true &amp;&amp; false</code> <code>false</code> <code>||</code> Logical OR <code>true || false</code> <code>true</code> <code>!</code> Logical NOT <code>!true</code> <code>false</code>"},{"location":"reference/operators/special/","title":"Special Operators","text":"<p>Betty provides special operators for handling ranges and list indexing efficiently.  </p> Feature Syntax Description Example Usage Range <code>[start..end]</code> Defines a range of values starting from <code>start</code>, incrementing by 1, and stopping before <code>end</code>. Internally calls <code>range()</code> function. <code>[1..4]</code> \u2192 <code>[1, 2, 3]</code> List Indexing <code>listvar[indexer]</code> Accesses elements within a list using an index, which can be a number, variable, or function call. <code>a = [1, 2, 3];</code> <code>print(a[0]);</code> \u2192 <code>1</code>"},{"location":"reference/standard-library/","title":"Standard Library","text":"<p>The Betty standard library provides essential functions for common programming tasks, from I/O operations to mathematical computations.</p> <ul> <li> <p> Char</p> </li> <li> <p> Conversion</p> </li> <li> <p> IO</p> </li> <li> <p> List</p> </li> <li> <p> Math</p> </li> <li> <p> String</p> </li> </ul>"},{"location":"reference/standard-library/char/","title":"Char","text":""},{"location":"reference/standard-library/char/#isdigit","title":"isdigit","text":"Property Details Function <code>isdigit(value)</code> Description Returns <code>true</code> if value is a digit (0-9), otherwise <code>false</code>. Parameters <code>value</code> (char) \u2013 The character to check. Return Type <code>bool</code> Errors Throws an exception if value is not a character. Example <code>isdigit('5')</code> \u2192 <code>true</code><code>isdigit('a')</code> \u2192 <code>false</code>"},{"location":"reference/standard-library/char/#isspace","title":"isspace","text":"Property Details Function <code>isspace(value)</code> Description Returns <code>true</code> if value is a whitespace character (e.g., space, tab, newline), otherwise <code>false</code>. Parameters <code>value</code> (char) \u2013 The character to check. Return Type <code>bool</code> Errors Throws an exception if value is not a character. Example <code>isspace(' ')</code> \u2192 <code>true</code><code>isspace('\\t')</code> \u2192 <code>true</code><code>isspace('a')</code> \u2192 <code>false</code>"},{"location":"reference/standard-library/conversion/","title":"Conversion","text":""},{"location":"reference/standard-library/conversion/#tobool","title":"tobool","text":"Property Details Function <code>tobool(value)</code> Description Converts value to a boolean. Numbers, characters, and strings follow specific truthiness rules. Parameters <code>value</code> (number, char, string, or bool) \u2013 The value to convert. Return Type <code>bool</code> Conversion Rules Numbers: <code>0</code> \u2192 <code>false</code>, nonzero \u2192 <code>true</code>Chars: Always <code>true</code>Strings: <code>\"true\"</code> \u2192 <code>true</code>, <code>\"false\"</code> \u2192 <code>false</code>, empty \u2192 <code>false</code>, non-empty \u2192 <code>true</code>Booleans: Returned as-is Errors Throws an exception if value is an unsupported type. Example <code>tobool(0)</code> \u2192 <code>false</code><code>tobool(42)</code> \u2192 <code>true</code><code>tobool('A')</code> \u2192 <code>true</code><code>tobool(\"\")</code> \u2192 <code>false</code><code>tobool(\"true\")</code> \u2192 <code>true</code><code>tobool(\"false\")</code> \u2192 <code>false</code>"},{"location":"reference/standard-library/conversion/#tochar","title":"tochar","text":"Property Details Function <code>tochar(value)</code> Description Converts value to a character if possible. Different types follow specific conversion rules. Parameters <code>value</code> (number, char, string, or bool) \u2013 The value to convert. Return Type <code>char</code> Conversion Rules Numbers: Cast to char if within valid range.Chars: Returned as-is.Strings: Must be exactly one character long.Booleans: <code>true</code> \u2192 <code>'T'</code>, <code>false</code> \u2192 <code>'F'</code> Errors Throws an exception if value is an unsupported type, a number outside the valid character range, or a string longer than one character. Example <code>tochar(65)</code> \u2192 <code>'A'</code><code>tochar('Z')</code> \u2192 <code>'Z'</code><code>tochar(\"B\")</code> \u2192 <code>'B'</code><code>tochar(true)</code> \u2192 <code>'T'</code><code>tochar(false)</code> \u2192 <code>'F'</code>"},{"location":"reference/standard-library/conversion/#tolist","title":"tolist","text":"Property Details Function <code>tolist(value)</code> Description Converts a string into a list of characters. Each character in the string becomes an individual element in the list. Parameters <code>value</code> (string) \u2013 The string to convert into a list of characters. Return Type <code>list</code> (of char) Errors Throws an exception if value is not a string. Example <code>tolist(\"abc\")</code> \u2192 <code>['a', 'b', 'c']</code><code>tolist(\"7\")</code> \u2192 <code>['7']</code>"},{"location":"reference/standard-library/conversion/#tonum","title":"tonum","text":"Property Details Function <code>tonum(value)</code> Description Converts a value into a number. Strings are parsed as numbers, booleans convert to 1 (true) or 0 (false), and characters are converted to their numeric values. Parameters <code>value</code> (char, string, boolean, or number) \u2013 The value to convert into a number. Return Type <code>number</code> Errors Throws an exception if value is a string that cannot be converted to a number or if value is of an unsupported type. Example <code>tonum('5')</code> \u2192 <code>5</code><code>tonum(\"42.3\")</code> \u2192 <code>42.3</code><code>tonum(true)</code> \u2192 <code>1</code><code>tonum(false)</code> \u2192 <code>0</code>"},{"location":"reference/standard-library/conversion/#tostr","title":"tostr","text":"Property Details Function <code>tostr(value)</code> Description Converts a value into a string representation. Parameters <code>value</code> (any type) \u2013 The value to convert into a string. Return Type <code>string</code> Errors None (all values have a string representation). Example <code>tostr(42)</code> \u2192 <code>\"42\"</code><code>tostr(true)</code> \u2192 <code>\"true\"</code><code>tostr('A')</code> \u2192 <code>\"A\"</code>"},{"location":"reference/standard-library/io/","title":"IO","text":""},{"location":"reference/standard-library/io/#input","title":"input","text":"Property Details Function <code>input(prompt)</code> Description Reads a line of input from the user. If a prompt string is provided, it is displayed before reading input. Parameters <code>prompt</code> (optional, string) \u2013 The text to display before waiting for input. Return Type <code>string</code> (the user's input) Errors Throws an error if more than one argument is provided. Example <code>input(\"Enter your name: \")</code> \u2192 Displays <code>Enter your name:</code> and waits for input.<code>input()</code> \u2192 Waits for input with no prompt."},{"location":"reference/standard-library/io/#printprintln","title":"print/println","text":"Property Details Function <code>print(args...)</code>, <code>println(args...)</code> Description Prints one or more arguments as a single concatenated string. <code>println</code> appends a newline at the end. Parameters <code>args...</code> (any type) \u2013 One or more values to print. Return Type <code>None</code> Errors None. Example <code>print(\"Hello, \", \"world!\")</code> \u2192 Prints <code>Hello, world!</code><code>println(\"Hello\")</code> \u2192 Prints <code>Hello</code> followed by a newline."},{"location":"reference/standard-library/list/","title":"List","text":""},{"location":"reference/standard-library/list/#append","title":"append","text":"Property Details Function <code>append(list, element)</code> Description Appends an element to a list. The first argument must be a list, and the second argument is the element to append to the list. Returns a new list with the appended element. Parameters <code>list</code> (List) \u2013 A list to which an element will be appended.<code>element</code> (Any Type) \u2013 The element to append to the list. Return Type <code>List</code> \u2013 A new list containing the appended element. Errors If the first argument is not a list, an error will occur.If the number of arguments is not exactly two, an error will occur. Example <code>append([1, 2, 3], 4)</code> \u2192 <code>[1, 2, 3, 4]</code>"},{"location":"reference/standard-library/list/#range","title":"range","text":"Property Details Function <code>range(start, end)</code> Description Creates a range of numbers starting from start (inclusive) and ending at end (exclusive). Returns a list of numbers in the specified range. Parameters <code>start</code> (Number) \u2013 The starting number of the range.<code>end</code> (Number) \u2013 The ending number of the range. Return Type <code>List</code> \u2013 A list of numbers from start to end (exclusive). Errors If the first or second argument is not a number, an error will occur.If the number of arguments is not exactly two, an error will occur. Example <code>range(1, 5)</code> \u2192 <code>[1, 2, 3, 4]</code>"},{"location":"reference/standard-library/list/#removeat","title":"removeat","text":"Property Details Function <code>removeat(list, index)</code> Description Removes the element at the specified index from the list. Returns a new list with the element at the given index removed. Parameters <code>list</code> (List) \u2013 The list from which to remove an element.<code>index</code> (Number) \u2013 The index of the element to remove from the list. Return Type <code>List</code> \u2013 A new list with the specified element removed. Errors If the first argument is not a list, an error will occur.If the second argument is not a number, an error will occur.If the index is out of range, an error will occur. Example <code>removeat([1, 2, 3, 4], 2)</code> \u2192 <code>[1, 2, 4]</code>"},{"location":"reference/standard-library/list/#remove","title":"remove","text":"Property Details Function <code>remove(list, element)</code> Description Removes the first occurrence of element from the list. Returns a new list with the element removed. Parameters <code>list</code> (List) \u2013 The list from which to remove an element.<code>element</code> (Any Type) \u2013 The element to remove from the list. Return Type <code>List</code> \u2013 A new list with the specified element removed. Errors If the first argument is not a list, an error will occur.If the number of arguments is not exactly two, an error will occur. Example <code>remove([1, 2, 3, 4], 3)</code> \u2192 <code>[1, 2, 4]</code>"},{"location":"reference/standard-library/math/","title":"Math","text":""},{"location":"reference/standard-library/math/#abs","title":"abs","text":"Property Details Function <code>abs(number)</code> Description Returns the absolute value of the given number. Parameters <code>number</code> (Number) \u2013 The number for which to return the absolute value. Return Type <code>Number</code> \u2013 The absolute value of the provided number. Errors If the argument is not a number, an error will occur.If the number of arguments is not exactly one, an error will occur. Example <code>abs(-5)</code> \u2192 <code>5</code><code>abs(3)</code> \u2192 <code>3</code>"},{"location":"reference/standard-library/math/#ceil","title":"ceil","text":"Property Details Function <code>ceil(number)</code> Description Returns the smallest integer greater than or equal to the given number. Parameters <code>number</code> (Number) \u2013 The number for which to return the ceiling value. Return Type <code>Number</code> \u2013 The smallest integer greater than or equal to the provided number. Errors If the argument is not a number, an error will occur.If the number of arguments is not exactly one, an error will occur. Example <code>ceil(4.2)</code> \u2192 <code>5</code><code>ceil(-1.7)</code> \u2192 <code>-1</code>"},{"location":"reference/standard-library/math/#cos","title":"cos","text":"Property Details Function <code>cos(number)</code> Description Returns the cosine of the given number (interpreted as an angle in radians). Parameters <code>number</code> (Number) \u2013 The angle in radians for which to compute the cosine value. Return Type <code>Number</code> \u2013 The cosine of the provided angle. Errors If the argument is not a number, an error will occur.If the number of arguments is not exactly one, an error will occur. Example <code>cos(0)</code> \u2192 <code>1</code>"},{"location":"reference/standard-library/math/#floor","title":"floor","text":"Property Details Function <code>floor(x)</code> Description Returns the largest integer less than or equal to x. Parameters <code>x</code> (Number) \u2013 The number to round down. Return Type <code>Number</code> Errors Throws an error if x is not a number. Example <code>floor(3.7)</code> \u2192 <code>3</code><code>floor(-2.3)</code> \u2192 <code>-3</code>"},{"location":"reference/standard-library/math/#pow","title":"pow","text":"Property Details Function <code>pow(base, exponent)</code> Description Returns base raised to the power of exponent. Parameters <code>base</code> (Number) \u2013 The base value.<code>exponent</code> (Number) \u2013 The exponent value. Return Type <code>Number</code> Errors Throws an error if arguments are not numbers. Example <code>pow(2, 3)</code> \u2192 <code>8</code><code>pow(5, 0.5)</code> \u2192 <code>2.236</code>"},{"location":"reference/standard-library/math/#sin","title":"sin","text":"Property Details Function <code>sin(angle)</code> Description Returns the sine of angle, where angle is given in radians. Parameters <code>angle</code> (Number) \u2013 The angle in radians. Return Type <code>Number</code> Errors Throws an error if the argument is not a number. Example <code>sin(0)</code> \u2192 <code>0</code><code>sin(3.14159 / 2)</code> \u2192 <code>1</code>"},{"location":"reference/standard-library/math/#sqrt","title":"sqrt","text":"Property Details Function <code>sqrt(number)</code> Description Returns the square root of number. Parameters <code>number</code> (Number) \u2013 The value to find the square root of. Return Type <code>Number</code> Errors Throws an error if the argument is not a number. Example <code>sqrt(9)</code> \u2192 <code>3</code><code>sqrt(2)</code> \u2192 <code>1.41421</code>"},{"location":"reference/standard-library/math/#tan","title":"tan","text":"Property Details Function <code>tan(number)</code> Description Returns the tangent of number, where number is in radians. Parameters <code>number</code> (Number) \u2013 The angle in radians. Return Type <code>Number</code> Errors Throws an error if the argument is not a number. Example <code>tan(0)</code> \u2192 <code>0</code><code>tan(pi / 4)</code> \u2192 <code>1</code>"},{"location":"reference/standard-library/string/","title":"String","text":""},{"location":"reference/standard-library/string/#concat","title":"concat","text":"Property Details Function <code>concat(value1, value2, ...)</code> Description Concatenates all given values into a single string. Parameters Any number of values of any type. Each value is converted to a string before concatenation. Return Type <code>String</code> Errors None. All values are implicitly converted to strings. Example <code>concat(\"Hello\", \" \", \"World!\")</code> \u2192 <code>\"Hello World!\"</code><code>concat(42, \" is the answer\")</code> \u2192 <code>\"42 is the answer\"</code>"},{"location":"reference/standard-library/string/#len","title":"len","text":"Property Details Function <code>len(value)</code> Description Returns the length of a string or list. Parameters <code>value</code> \u2013 A string or list. Return Type <code>Number</code> \u2013 The length of the string or list. Errors Throws an error if the argument is not a string or list. Example <code>len(\"Hello\")</code> \u2192 <code>5</code><code>len([1, 2, 3, 4])</code> \u2192 <code>4</code>"}]}