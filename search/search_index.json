{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Betty Language Reference","text":"<p>Welcome to the official documentation for Betty, a dynamic programming language designed for prototyping purposes. Betty supports various data types, has a standard library, and offers a simple and intuitive syntax.</p> <p>Warning</p> <p>This documentation is still a work in progress and does not cover all language features (such as lambdas) yet. Please check back for future updates!</p>"},{"location":"data-types/","title":"Data Types","text":"<p>The Betty programming language provides a range of data types, each serving a unique purpose.  </p> <ul> <li> <p> Number</p> <p>Represents both integers and floating-point values, supporting arithmetic and implicit conversions. </p> </li> <li> <p> String </p> <p>A sequence of characters with intrinsic functions for manipulation and formatting.</p> </li> <li> <p> Char </p> <p>A single character, internally stored as an ASCII value, allowing seamless numeric operations. </p> </li> <li> <p> Boolean </p> <p>Represents truth values (<code>true</code> or <code>false</code>) and is used in logical operations and control flow. </p> </li> <li> <p> List </p> <p>A dynamic, ordered collection of values that can hold mixed data types and be manipulated efficiently. </p> </li> <li> <p> None </p> <p>A special type representing the absence of a value, often used for implicit returns.  </p> </li> </ul>"},{"location":"data-types/boolean/","title":"Boolean","text":"<p>Boolean literals are represented with the <code>true</code> and <code>false</code> keywords, which are language-reserved and may not be used in another context. Logical operations in Betty require both operands to be of type <code>Boolean</code>. No implicit conversions between booleans and numeric values exist.</p> <pre><code>a = true;\n</code></pre>"},{"location":"data-types/char/","title":"Char","text":"<p>Character literals are encased between a pair of single quotes ( <code>'</code> ). Empty character literals are not allowed in Betty programs. A character literal may not consist of more than one character, save for escape sequences\u2014which essentially are single characters.</p> <pre><code>x = 'b';    # Valid\nx = '\\n';   # Valid, escape sequence\nx = '';     # Will throw, empty character literal\nx = 'ab';   # Will throw, multi-character literal\nx = ';      # Will throw, unterminated character literal\n</code></pre> <p>Note</p> <p>Some operations between numbers and characters (character arithmetic) are handled implicitly by the interpreter, to an extent. Refer to the operator documentation syntax for further details, as well as to explore options for handling such operations explicitly.</p>"},{"location":"data-types/list/","title":"List","text":"<p>Lists are currently the sole data structure of the Betty language, its bread and butter so to speak. Aided by the language's dynamic design, lists are very versatile in terms of their usage and what they can accomplish.</p> <p>Betty allows lists containing multiple data types, even different (nested) lists. Despite the lack of other data structures in the language, the flexibility achieved through this alone enables for \"custom\" record-like structures, even\u2014admittedly lesser-performing\u2014 maps.</p> <p>Note</p> <p>In the code examples section of the documentation, you can find a partial, preliminary attempt at bootstrapping (self-hosting) the Betty interpreter, showcasing the language's potential. Naturally, although such an implementation would result in less-than-ideal execution times, it is nonetheless a rather fun theoretical endeavor to take on.</p> <p>Betty is primarily a prototyping language, that much is certain. Be that as it may, the presence of lists\u2014along with some useful standard library functions, can assist the user in coding solutions to a multitude of problems. That was a major consideration in the way lists are implemented.</p> <p>One of the goals in the development process was to provide the programmer with ways to create something more meaningful than your typical \"Hello World,\" even at the cost of potential performance (the unavoidable tree-walk interpreter baggage). Whether they decide to \"get their hands dirty\" is ultimately left up to the user.</p> <pre><code>x = [1, 2, 3, 4];\nx = [1..5];             # Same declaration with range syntax\nx = [[1, 2], [3, 4]];   # Nested lists\n</code></pre>"},{"location":"data-types/list/#string-indexing","title":"String indexing","text":"<p>Betty supports indexing strings and accessing them as character lists out-of-the-box, in alignment with the default behavior in various programming languages.</p> <pre><code>print(\"hello\"[1]); # Will print `e`\n</code></pre>"},{"location":"data-types/none/","title":"None","text":"<p><code>None</code> is a special data type, in terms of how it works in Betty. It is not one of the language's keywords and neither variables nor functions can be assigned it. </p> <p>Nullability support can be a rather controversial topic among language designers, as including support for it could potentially lead to a plethora of runtime errors, like when dereferencing null pointers.</p> <p>What is more, extending a language to support null and nullable types can introduce a whole new layer of complexity (oftentimes unnecessary).</p> <p>However, allowing implicit returns of a <code>unit</code>-like value (<code>None</code>, in our case) can be beneficial in handling cases like the default return value of functions. Betty is a dynamic language, therefore a single function can return multiple data types. Introducing a default return value mitigates a significant class of potential issues and ensures all code paths have a return value.</p> <p>Under the hood, it is far more convenient to implement a visitor pattern in the interpreter, when all node visits result in the return of a uniform <code>Value</code> struct (with <code>None</code> as a potential value type). In this manner, there's no need for special handling of uninitialized or absent returns in dynamic typing contexts. It also avoids runtime surprises when a function unexpectedly fails to return a value.</p> <p>It should further be noted that since Betty allows expression-statements as first-class citizens, functions can be executed solely for their side effects and have their values discarded.</p> <pre><code>print(\"Hello, world!\"); # Valid, clearly intended for the side effect.\n</code></pre>"},{"location":"data-types/number/","title":"Number","text":"<p>Betty uses a universal <code>number</code> data type to represent both integers and real numbers. Internally, all numeric values are stored as <code>double</code> for ease of handling. The language does, in fact, offer ways to work with strictly integer values, at least on the surface level, should one wish to do so.</p> <p>For instance, there are built-in math functions baked into the language for both <code>floor()</code> and <code>ceil()</code>. Additionally, there exists an integer division operator ( <code>//</code> ), which performs normal double division then floors the result, as is the case in several programming languages (e.g. Python, Ruby).</p> <pre><code>12\n0.5\n0.002\n-3\n</code></pre> <p>Under the hood, Betty leverages C#'s and, by extension, .NET's own <code>double</code> primitive value type, which means edge cases such as <code>infinity</code> and <code>NaN</code> are handled by the underlying framework implementation at the binary level.</p>"},{"location":"data-types/string/","title":"String","text":"<p>Strings in Betty are enclosed between a pair of double quotes ( <code>\"</code> ). They are interned using a string lookup table so they can be lightweight\u2014in terms of memory overhead and allocations (on the stack vs. the heap), as well as be accessed very fast in ideal usage scenarios.</p> <pre><code>\"Hello, World!\";\n</code></pre> <p>In an addition operation, if either operand is a <code>string</code>, then the result is concatenated and returned as a <code>string</code>. This has been implemented to match the expected behavior in several programming languages.</p> <pre><code>\"Hi \" + 5; # Returns \"Hi 5\"\n</code></pre> <p>Furthermore, in addition to equality and inequality operations, strings allow comparisons like <code>&gt;</code> and <code>&lt;</code>, based on lexicographical order. This behavior may not always make intuitive sense to a newer programmer, nonetheless it is supported in plenty of programming languages. In the back-end, C#'s <code>CompareTo</code> standard library function (akin to <code>strcmp</code> in C) is utilized.</p> <pre><code>\"apple\" &lt; \"banana\"; # Returns `true`, since 'a' is less than 'b'\n</code></pre> <p>Compound (shorthand assignment) is supported in strings only through the addition ( <code>+</code> ) operator.</p>"},{"location":"data-types/string/#escape-sequences","title":"Escape sequences","text":"Sequence Description <code>\\n</code> Newline <code>\\t</code> Tab <code>\\\"</code> Double quote <code>\\'</code> Single quote <code>\\\\</code> Backslash <code>\\0</code> Null character <p>Note</p> <p>Character literals also support the aforementioned sequences.</p>"},{"location":"examples/","title":"Examples","text":"<p>Explore practical examples demonstrating Betty's features and capabilities, from basic syntax to advanced programming concepts.</p> <ul> <li> <p> Example 1: Functions and Unary Operations</p> <p>Demonstrates how to define a function and use post-increment and pre-increment operations.</p> </li> <li> <p> Example 2: Implicit Conversions and Arithmetic</p> <p>Discover how Betty handles automatic type conversions and performs arithmetic operations across different data types.</p> </li> <li> <p> Example 3: Comments and Integer Division</p> <p>Understand Betty's commenting syntax and explore integer division behavior with practical examples.</p> </li> <li> <p> Example 4: Character Operations</p> <p>Work with individual characters, perform ASCII manipulations, and explore character-based operations.</p> </li> <li> <p> Example 5: Control Flow and Recursion</p> <p>A simple demonstration of recursion and the <code>if</code> control structure to calculate a factorial.</p> </li> <li> <p> Example 6: Loops and Conditionals</p> <p>Build iteration logic with loops and make decisions using conditional statements for dynamic program behavior.</p> </li> <li> <p> Example 7: Expression Evaluator</p> <p>Implement a complete expression evaluator demonstrating parsing, evaluation, and advanced language features.</p> </li> </ul>"},{"location":"examples/char-operations/","title":"Example 4: Character Operations","text":"<p>This example demonstrates character increment and explicit conversion to character type.</p> <pre><code>x = 'a';\nx = tochar(++x);    # Increment 'a' to 'b', then convert explicitly to char\nprint(x);           # Prints 'b'\n</code></pre>"},{"location":"examples/comments-int-division/","title":"Example 3: Comments and Integer Division","text":"<p>Illustrates the use of integer division shorthand and how to include comments.</p> <pre><code>func divisionExample()\n{\n    x = 10;\n    y = 20;\n    y //= 2;    # Integer division shorthand\n    print(y);   # Outputs 10\n\n    # This is a comment explaining that the next line prints the value of x\n\n    print(x);   # Outputs 10\n}\n\nfunc main()\n{\n    divisionExample();\n}\n</code></pre>"},{"location":"examples/control-flow-recursion/","title":"Example 5: Control Flow and Recursion","text":"<p>A simple demonstration of recursion and the <code>if</code> control structure to calculate a factorial.</p> <pre><code>func factorial(n)\n{\n    if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return n * factorial(n - 1);    # Recursive call\n    }\n}\n\nfunc main()\n{\n    result = factorial(5);\n    print(result);                      # Should print 120, the factorial of 5\n}\n</code></pre>"},{"location":"examples/expression-evaluator/","title":"Example 7: Expression Evaluator","text":"<p>This is a mathematical expression evaluator implemented in Betty, showcasing the language\u2019s self-hosting (bootstrapping) potential.</p> <pre><code>### GLOBALS ###\n# Tokenizer\nglobal text;\nglobal pos;\nglobal currentChar;\n# Parser\nglobal tokens;\nglobal currentTokenIndex;\n### END GLOBALS ###\n\n### LEXER ###\n\nfunc advance()\n{\n    pos++;\n    if (pos &gt;= len(text))\n        currentChar = '\\0';\n    else\n        currentChar = text[pos];\n}\n\nfunc skipWhitespace()\n{\n    while (currentChar != '\\0' &amp;&amp; isspace(currentChar))\n        advance();\n}\n\nfunc initTokenizer(s)\n{\n    text = s;\n    pos = 0;\n    currentChar = text[pos];\n}\n\nfunc tokenize()\n{\n    # Initialize empty token list\n    tokList = [];\n    while (currentChar != '\\0')\n    {\n        if (isspace(currentChar))\n        {\n            skipWhitespace();\n            continue;\n        }\n        if (isdigit(currentChar))\n        {\n            number = \"\";\n            while (isdigit(currentChar))\n            {\n                number += tostr(currentChar);\n                advance();\n            }\n            tokList += [[\"Number\", tonum(number)]];\n            continue;\n        }\n        if (currentChar == '+'\n            || currentChar == '-'\n            || currentChar == '*'\n            || currentChar == '/') \n            {\n                tokList += [[\"BinOp\", currentChar]];\n                advance();\n                continue;\n            }\n        if (currentChar == '(' || currentChar == ')')\n        {\n            tokList += [[\"Paren\", currentChar]];\n            advance();\n            continue;\n        }\n        print(\"Error: Unrecognized character: \" + currentChar + \"\\n\");\n        break;\n    }\n    return tokList;\n}\n\n### END LEXER ###\n\n### PARSER ###\n\n# Initializes the parser with the tokens produced by the tokenizer\nfunc initParser(tokList)\n{\n    tokens = tokList;\n    currentTokenIndex = 0;\n}\n\n# Returns the current token without advancing\nfunc peekToken()\n{\n    if (currentTokenIndex &lt; len(tokens))\n        return tokens[currentTokenIndex];\n    return [\"EOF\", 0]; # End of tokens\n}\n\n# Returns the next token and advances the cursor\nfunc nextToken()\n{\n    token = peekToken();\n    if (token[0] != \"EOF\")\n        currentTokenIndex++;\n    return token;\n}\n\n# Parse a factor: a number or an expression in parentheses\nfunc parseFactor()\n{\n    token = nextToken();\n    if (token[0] == \"Number\") \n    {\n        return token[1]; # Return the numerical value\n    } \n    elif (token[0] == \"Paren\" &amp;&amp; token[1] == '(')\n    {\n        result = parseExpr(); # Parse the expression inside the parentheses\n        closingParen = nextToken();\n        if (closingParen[0] != \"Paren\" || closingParen[1] != ')')\n        {\n            println(\"Error: Expected ')'\");\n            return 0;\n        }\n        return result;\n    }\n    println(\"Error: Unexpected token in factor\");\n    return 0;\n}\n\n# Parse a term: a factor followed by '*' or '/' operators\nfunc parseTerm()\n{\n    result = parseFactor();\n    while (true)\n    {\n        token = peekToken();\n        if (token[0] == \"BinOp\" &amp;&amp; (token[1] == '*' || token[1] == '/'))\n        {\n            nextToken(); # Consume the operator\n            if (token[1] == '*')\n            {\n                result *= parseFactor();\n            }\n            elif (token[1] == '/')\n            {\n                result /= parseFactor();\n            }\n        }\n        else \n        {\n            break;\n        }\n    }\n    return result;\n}\n\n# Parse an expression: a term followed by '+' or '-' operators\nfunc parseExpr() \n{\n    result = parseTerm();\n    while (true) \n    {\n        token = peekToken();\n        if (token[0] == \"BinOp\" &amp;&amp; (token[1] == '+' || token[1] == '-'))\n        {\n            nextToken(); # Consume the operator\n            if (token[1] == '+') \n            {\n                result += parseTerm();\n            } \n            elif (token[1] == '-') \n            {\n                result -= parseTerm();\n            }\n        } \n        else \n        {\n            break;\n        }\n    }\n    return result;\n}\n\n# Main evaluation function that wraps the tokenizer and parser initialization and starts the parsing process\nfunc evaluate(expr) \n{\n    # Initialize the tokenizer\n    initTokenizer(expr);\n    # Tokenize the expression first\n    tokenList = tokenize();\n    # Initialize the parser with the token list\n    initParser(tokenList);\n    # Start parsing from the expression level\n    result = parseExpr();\n    println(\"Result: \", result);\n}\n\n### END PARSER ###\n\n# Entry point\nfunc main() \n{\n    while (true) \n    {\n        expr = input(\"&gt; \");\n        evaluate(expr);\n    }\n}\n</code></pre>"},{"location":"examples/functions-unary-operations/","title":"Example 1: Functions and Unary Operations","text":"<p>Demonstrates how to define a function and use post-increment and pre-increment operations.</p> <pre><code>func increment()\n{\n    count = 0;\n    count = count++ + ++count;  # Post-increment and pre-increment\n    print(count);               # Should output 2, demonstrating how increment operations work\n}\n\nfunc main()\n{\n    increment();\n}\n</code></pre>"},{"location":"examples/implicit-conversions-arithmetic/","title":"Example 2: Implicit Conversions and Arithmetic","text":"<p>Discover how Betty handles automatic type conversions and performs arithmetic operations across different data types.</p> <pre><code>func charArithmetic()\n{\n    charValue = 'a';\n    charValue += 1;     # Implicitly converts 'a' to its ASCII value, then increments\n    print(charValue);   # Outputs the number corresponding to 'b' in ASCII\n    numberValue = 10;\n    numberValue += '3'; # '3' is implicitly converted to its numeric ASCII value before addition\n    print(numberValue); # Outputs the result of the addition\n}\n</code></pre>"},{"location":"examples/loops-conditionals/","title":"Example 6: Loops and Conditionals","text":"<p>Showcases loops (<code>while</code>, <code>for</code>) and conditional (<code>if-else</code>) statements.</p> <pre><code>func loopExamples()\n{\n    # While loop example\n    i = 0;\n    while (i &lt; 5)\n    {\n        print(i);\n        i++;\n    }\n\n    # For loop example\n    for (j = 0; j &lt; 5; j++)\n    {\n        print(j);\n    }\n\n    # If-else example\n    if (i == 5)\n    {\n        print(\"Loop completed with while\");\n    }\n    else\n    {\n        print(\"Unexpected value\");\n    }\n}\n\nfunc main()\n{\n    loopExamples();\n}\n</code></pre>"},{"location":"keywords/","title":"Keywords","text":"<p>Betty's reserved keywords form the foundation of the language, enabling control flow, function definitions, and variable management.</p> <ul> <li> <p> Control Flow</p> <p>Keywords for conditional execution and program flow control, including <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, and loop control statements.</p> </li> <li> <p> Functions</p> <p>Keywords for defining and working with functions, including <code>func</code>.</p> </li> <li> <p> Variables and Scope</p> <p>Keyword for global variable declarations.</p> </li> </ul>"},{"location":"keywords/control-flow/","title":"Control Flow","text":""},{"location":"keywords/control-flow/#break-continue-return","title":"<code>break</code> / <code>continue</code> / <code>return</code>","text":"<p>These control flow keywords are an integral part of the C-like programming languages family (and many other families!).</p> <ul> <li><code>break</code>: Breaks out of a loop construct, resuming execution at the first statement after the loop\u2019s body.</li> <li><code>continue</code>: Prematurely ends the current iteration of a loop, jumping to the start of the next iteration.</li> <li><code>return</code>: Returns control of the program to a function\u2019s caller. If this statement is executed within a program\u2019s <code>main()</code> method, control is returned to the operating system, effectively terminating the program.</li> </ul>"},{"location":"keywords/control-flow/#if-elif-else","title":"<code>if</code> / <code>elif</code> / <code>else</code>","text":"<p>Your standard issue, run-of-the-mill conditionals. <code>if</code> statements are used to execute a block of code, depending on whether a condition is true. An <code>if</code> statement can optionally be accompanied by a single or many <code>elif</code> statements, as well as an optional <code>else</code> statement at the end.</p> <p>This is what the complete structure looks like.</p> <pre><code>if (cond)\n{\n    # if-body\n}\nelif (elsecond)\n{\n    # elif-body\n}\nelse\n{\n    # else-body\n}\n</code></pre>"},{"location":"keywords/control-flow/#for-foreach","title":"<code>for</code> / <code>foreach</code>","text":"<p>Although a language can do fine with just a while loop, for (and for-each) loops are a staple in C-like languages.</p> <pre><code>for (initializer; condition; increment)\n{\n    # body\n}\n</code></pre> <p>Note</p> <p>In Betty, you may create a <code>for</code> loop without an initializer, condition or increment expression, or any other combination. This behavior closely aligns with how <code>for</code> loops work in many programming languages and was implemented in this manner for consistency purposes. Thus, <code>for (; ;)</code> can be used to create a non-terminating loop.</p> <p>The for-each loop uses the <code>in</code> keyword, expecting an iterable expression (like a list) after it.</p> <pre><code>foreach (variableName in iterable)\n{\n    # body\n}\n</code></pre> <p>For-each loops can additionally be used to iterate through ranges and strings.</p> <p>Range iteration: <pre><code>foreach (i in [1..5])\n{\n    println(i);     # Prints the numbers 1 to 4\n}\n</code></pre></p> <p>String iteration: <pre><code>s = \"Hello, World!\";\nforeach (c in s)\n{\n    println(c);     # Prints each character in the string\n}\n</code></pre></p>"},{"location":"keywords/control-flow/#while-do-while","title":"<code>while</code> / <code>do while</code>","text":"<p>While and do-while loops in Betty use standard syntax.</p> <p>While loop: <pre><code>while (condition)\n{\n    # body\n}\n</code></pre></p> <p>Do-while loop: <pre><code>do\n{\n    # body\n} while (cond)\n</code></pre></p> <p>Note</p> <p>The body of any construct in Betty can either be a single statement or a compound statement (list of statements). In the case of singular statements, braces ( <code>{</code> <code>}</code> ) are not required. It is recommended that you use proper indentation and spacing to distinguish such statements from the statements succeeding them, ensuring code readability, should you choose to make use of this feature.</p>"},{"location":"keywords/functions/","title":"Functions","text":""},{"location":"keywords/functions/#func","title":"<code>func</code>","text":"<p>The <code>func</code> keyword is used to begin a function definition. Functions in Betty are defined at the root level.</p> <pre><code>func foo(param1, param2, ... , paramn)\n{\n    # body\n}\n</code></pre> <p>Empty function definitions are valid in Betty, however duplicate definitions are not. Function overloading is not supported at this moment.</p> <p>Every Betty program requires a <code>main()</code> function as an entry point. If the interpreter does not find one, an error will be raised. Intrinsic function (standard library) function names are reserved and cannot be overridden. For a comprehensive list of all built-in functions, refer to the Standard Library.</p> <p>Note</p> <p>Due to the dynamic nature of the Betty language, different code paths are allowed to return different data types. All functions, when in a code path where a return statement is omitted, implicitly return to the caller the unit-like value <code>None</code>, Betty\u2019s \u201csecret\u201d type. Refer to the <code>None</code> data type documentation for details.</p>"},{"location":"keywords/variables-and-scope/","title":"Variables and Scope","text":""},{"location":"keywords/variables-and-scope/#global","title":"<code>global</code>","text":"<p>The <code>global</code> keyword is used to declare a global, program-wide variable. Global variable declarations in Betty are top-level statements. Global variables cannot be assigned to on declaration and cannot be shadowed. They can be declared anywhere in the code\u2019s root level, nonetheless it is encouraged to declare them at the start of the program.</p> <p>The decision to include global variables in a programming language can admittedly be rather controversial, as such a design strays away from pure and clean programming practices. Care should be exercised, as careless usage of globals can be headache-inducing.</p> <p>That being said, Betty\u2019s syntax for global variables is very straightforward.</p> <pre><code>global x;           # Declares \u2018x\u2019 as a global variable\n\nfunc side_effect()\n{\n    x = 10;\n}\n\nfunc main()\n{\n    x = 2;\n    side_effect();\n    print(x);       # Will print \u201810\u2019\n}\n</code></pre>"},{"location":"operators/","title":"Operators","text":"<p>Operators in Betty provide powerful ways to perform calculations, compare values, and control execution flow.  </p> <ul> <li> <p> Arithmetic </p> <p>Perform fundamental mathematical operations like addition, subtraction, multiplication, and division.  </p> </li> <li> <p> Logical </p> <p>Combine boolean values and control decision-making with AND, OR, and NOT operations.</p> </li> <li> <p> Comparative </p> <p>Compare numbers, strings, and other data types to determine equality, order, and differences.</p> </li> <li> <p> Conditional</p> <p>Use the ternary operator to make concise, inline decisions based on conditions.</p> </li> <li> <p> Assignment </p> <p>Assign values to variables and modify them efficiently with compound assignment operators.</p> </li> <li> <p> Special </p> <p>Work with unique syntax features like ranges and list indexing for efficient data handling.</p> </li> </ul>"},{"location":"operators/arithmetic/","title":"Arithmetic Operators","text":"Operator Description Example <code>+</code> Addition <code>1 + 2</code> \u2192 <code>3</code> <code>-</code> Subtraction <code>5 - 3</code> \u2192 <code>2</code> <code>*</code> Multiplication <code>4 * 2</code> \u2192 <code>8</code> <code>/</code> Division <code>8 / 2</code> \u2192 <code>4</code> <code>%</code> Modulus <code>10 % 3</code> \u2192 <code>1</code> <code>^</code> Exponentiation <code>2 ^ 3</code> \u2192 <code>8</code> <code>//</code> Floor Division <code>7 // 2</code> \u2192 <code>3</code>"},{"location":"operators/arithmetic/#addition-overloads","title":"Addition overloads","text":""},{"location":"operators/arithmetic/#string-concatenation","title":"String concatenation","text":"<p>The addition operator has been overloaded to support string concatenation. Therefore, syntax such as <code>\"Hello \" + \"World\"</code> is possible in Betty.</p> <p>Note</p> <p>String concatenation is also supported through an appropriately-named <code>concat()</code> built-in language function, as well as the <code>print()</code> function itself. Further examples of string manipulation can be found in the intrinsic functions documentation.</p>"},{"location":"operators/arithmetic/#list-operand-addition","title":"List-operand addition","text":"<p>If either operand of an addition operation is a <code>list</code>, the interpreter will append the other operand to it\u2014either at the beginning or the end, depending on the operand order. If both operands are lists, the second list will be appended to the end of the first.</p> <p>Since lists are reference types in Betty, this operation modifies the original list rather than creating a new one.</p> <p>Cases:</p> <ul> <li><code>list + element</code> would append <code>element</code> to the end of <code>list</code>.</li> <li><code>element + list</code> would prepend <code>element</code> to the beginning of <code>list</code>.</li> <li><code>list1 + list2</code> would append <code>list2</code> to <code>list1</code>, modifying <code>list1</code>.</li> </ul> <p>Example:</p> <pre><code>a = \"hello\";\nb = [1, 2];\nreturn b + a; # Will append the string to the end of `b`, i.e. [1, 2, \"hello\"]\n</code></pre>"},{"location":"operators/arithmetic/#implicit-conversions","title":"Implicit conversions","text":"<p>For the sake of convenience and flexibility, Betty will handle some common scenarios implicitly, as far as the expected outcome of \"adding\" different data types is concerned. For those who prefer boldness and completeness over simplicity\u2014although type hinting is not a feature\u2014the language constructs do allow you to explicitly specify most conversion operations.</p>"},{"location":"operators/arithmetic/#character-arithmetic","title":"Character arithmetic","text":"<p>In Betty, characters are implicitly converted to their ASCII values when used in arithmetic operations. This allows direct manipulation of characters as numeric values.</p> <pre><code>charValue = 'a';\ncharValue += 1;         # Implicitly converts 'a' to its ASCII value, then increments\nprint(charValue);       # Outputs the number corresponding to 'b' in ASCII\nnumberValue = 10;\nnumberValue += '3';     # '3' is implicitly converted to its numeric ASCII value before addition\nprint(numberValue);     # Outputs the result of the addition\n</code></pre> <p>Note</p> <p>As types in Betty are, for the most part, not strictly enforced, the interpreter will automatically handle conversions like these to reduce friction and boilerplate code.</p> <p>Warning</p> <p>In order to avoid confusion and ensure clarity, an explicit conversion back to <code>char</code> would be needed in order to print the character representations in the example.</p>"},{"location":"operators/assignment/","title":"Assignment Operators","text":"Operator Description Example Equivalent To <code>=</code> Assign value <code>x = 5</code> <code>x = 5</code>"},{"location":"operators/assignment/#compound-assignment","title":"Compound assignment","text":"Operator Description Example Equivalent To <code>+=</code> Add and assign <code>x += 3</code> <code>x = x + 3</code> <code>-=</code> Subtract and assign <code>x -= 2</code> <code>x = x - 2</code> <code>*=</code> Multiply and assign <code>x *= 4</code> <code>x = x * 4</code> <code>/=</code> Divide and assign <code>x /= 2</code> <code>x = x / 2</code> <code>%=</code> Modulus and assign <code>x %= 3</code> <code>x = x % 3</code> <code>^=</code> Exponentiate and assign <code>x ^= 2</code> <code>x = x ^ 2</code> <code>//=</code> Floor divide and assign <code>x //= 2</code> <code>x = x // 2</code>"},{"location":"operators/assignment/#prefix-postfix-incrementdecrement","title":"Prefix &amp; postfix increment/decrement","text":"Operator Type Description Example Result <code>++x</code> Prefix Increments <code>x</code> before evaluation <code>x = 5; y = ++x;</code> <code>x = 6, y = 6</code> <code>x++</code> Postfix Increments <code>x</code> after evaluation <code>x = 5; y = x++;</code> <code>x = 6, y = 5</code> <code>--x</code> Prefix Decrements <code>x</code> before evaluation <code>x = 5; y = --x;</code> <code>x = 4, y = 4</code> <code>x--</code> Postfix Decrements <code>x</code> after evaluation <code>x = 5; y = x--;</code> <code>x = 4, y = 5</code>"},{"location":"operators/comparative/","title":"Comparative Operators","text":"Operator Description Example Result <code>==</code> Equal to <code>5 == 5</code> <code>true</code> <code>!=</code> Not equal to <code>5 != 3</code> <code>true</code> <code>&gt;</code> Greater than <code>7 &gt; 4</code> <code>true</code> <code>&lt;</code> Less than <code>3 &lt; 8</code> <code>true</code> <code>&gt;=</code> Greater than or equal to <code>6 &gt;= 6</code> <code>true</code> <code>&lt;=</code> Less than or equal to <code>2 &lt;= 5</code> <code>true</code>"},{"location":"operators/conditional/","title":"Conditional Operators","text":"Operator Description Example Result <code>? :</code> Ternary conditional (if-else) <code>x = (5 &gt; 3) ? \"yes\" : \"no\";</code> <code>\"yes\"</code>"},{"location":"operators/logical/","title":"Logical Operators","text":"Operator Description Example Result <code>&amp;&amp;</code> Logical AND <code>true &amp;&amp; false</code> <code>false</code> <code>||</code> Logical OR <code>true || false</code> <code>true</code> <code>!</code> Logical NOT <code>!true</code> <code>false</code>"},{"location":"operators/special/","title":"Special Operators","text":"<p>Betty provides special operators for handling ranges and list indexing efficiently.  </p> Feature Syntax Description Example Usage Range <code>[start..end]</code> Defines a range of values starting from <code>start</code>, incrementing by 1, and stopping before <code>end</code>. Internally calls <code>range()</code> function. <code>[1..4]</code> \u2192 <code>[1, 2, 3]</code> List Indexing <code>listvar[indexer]</code> Accesses elements within a list using an index, which can be a number, variable, or function call. <code>a = [1, 2, 3];</code> <code>print(a[0]);</code> \u2192 <code>1</code>"},{"location":"standard-library/","title":"Standard Library","text":"<p>The Betty standard library provides essential functions for common programming tasks, from I/O operations to mathematical computations.</p> <ul> <li> <p> Char</p> </li> <li> <p> Conversion</p> </li> <li> <p> IO</p> </li> <li> <p> List</p> </li> <li> <p> Math</p> </li> <li> <p> String</p> </li> </ul>"},{"location":"standard-library/char/","title":"Char","text":""},{"location":"standard-library/char/#isdigit","title":"isdigit","text":"Property Details Function <code>isdigit(value)</code> Description Returns <code>true</code> if value is a digit (0-9), otherwise <code>false</code>. Parameters <code>value</code> (char) \u2013 The character to check. Return Type <code>bool</code> Errors Throws an exception if value is not a character. Example <code>isdigit('5')</code> \u2192 <code>true</code><code>isdigit('a')</code> \u2192 <code>false</code>"},{"location":"standard-library/char/#isspace","title":"isspace","text":"Property Details Function <code>isspace(value)</code> Description Returns <code>true</code> if value is a whitespace character (e.g., space, tab, newline), otherwise <code>false</code>. Parameters <code>value</code> (char) \u2013 The character to check. Return Type <code>bool</code> Errors Throws an exception if value is not a character. Example <code>isspace(' ')</code> \u2192 <code>true</code><code>isspace('\\t')</code> \u2192 <code>true</code><code>isspace('a')</code> \u2192 <code>false</code>"},{"location":"standard-library/conversion/","title":"Conversion","text":""},{"location":"standard-library/conversion/#tobool","title":"tobool","text":"Property Details Function <code>tobool(value)</code> Description Converts value to a boolean. Numbers, characters, and strings follow specific truthiness rules. Parameters <code>value</code> (number, char, string, or bool) \u2013 The value to convert. Return Type <code>bool</code> Conversion Rules Numbers: <code>0</code> \u2192 <code>false</code>, nonzero \u2192 <code>true</code>Chars: Always <code>true</code>Strings: <code>\"true\"</code> \u2192 <code>true</code>, <code>\"false\"</code> \u2192 <code>false</code>, empty \u2192 <code>false</code>, non-empty \u2192 <code>true</code>Booleans: Returned as-is Errors Throws an exception if value is an unsupported type. Example <code>tobool(0)</code> \u2192 <code>false</code><code>tobool(42)</code> \u2192 <code>true</code><code>tobool('A')</code> \u2192 <code>true</code><code>tobool(\"\")</code> \u2192 <code>false</code><code>tobool(\"true\")</code> \u2192 <code>true</code><code>tobool(\"false\")</code> \u2192 <code>false</code>"},{"location":"standard-library/conversion/#tochar","title":"tochar","text":"Property Details Function <code>tochar(value)</code> Description Converts value to a character if possible. Different types follow specific conversion rules. Parameters <code>value</code> (number, char, string, or bool) \u2013 The value to convert. Return Type <code>char</code> Conversion Rules Numbers: Cast to char if within valid range.Chars: Returned as-is.Strings: Must be exactly one character long.Booleans: <code>true</code> \u2192 <code>'T'</code>, <code>false</code> \u2192 <code>'F'</code> Errors Throws an exception if value is an unsupported type, a number outside the valid character range, or a string longer than one character. Example <code>tochar(65)</code> \u2192 <code>'A'</code><code>tochar('Z')</code> \u2192 <code>'Z'</code><code>tochar(\"B\")</code> \u2192 <code>'B'</code><code>tochar(true)</code> \u2192 <code>'T'</code><code>tochar(false)</code> \u2192 <code>'F'</code>"},{"location":"standard-library/conversion/#tolist","title":"tolist","text":"Property Details Function <code>tolist(value)</code> Description Converts a string into a list of characters. Each character in the string becomes an individual element in the list. Parameters <code>value</code> (string) \u2013 The string to convert into a list of characters. Return Type <code>list</code> (of char) Errors Throws an exception if value is not a string. Example <code>tolist(\"abc\")</code> \u2192 <code>['a', 'b', 'c']</code><code>tolist(\"7\")</code> \u2192 <code>['7']</code>"},{"location":"standard-library/conversion/#tonum","title":"tonum","text":"Property Details Function <code>tonum(value)</code> Description Converts a value into a number. Strings are parsed as numbers, booleans convert to 1 (true) or 0 (false), and characters are converted to their numeric values. Parameters <code>value</code> (char, string, boolean, or number) \u2013 The value to convert into a number. Return Type <code>number</code> Errors Throws an exception if value is a string that cannot be converted to a number or if value is of an unsupported type. Example <code>tonum('5')</code> \u2192 <code>5</code><code>tonum(\"42.3\")</code> \u2192 <code>42.3</code><code>tonum(true)</code> \u2192 <code>1</code><code>tonum(false)</code> \u2192 <code>0</code>"},{"location":"standard-library/conversion/#tostr","title":"tostr","text":"Property Details Function <code>tostr(value)</code> Description Converts a value into a string representation. Parameters <code>value</code> (any type) \u2013 The value to convert into a string. Return Type <code>string</code> Errors None (all values have a string representation). Example <code>tostr(42)</code> \u2192 <code>\"42\"</code><code>tostr(true)</code> \u2192 <code>\"true\"</code><code>tostr('A')</code> \u2192 <code>\"A\"</code>"},{"location":"standard-library/io/","title":"IO","text":""},{"location":"standard-library/io/#input","title":"input","text":"Property Details Function <code>input(prompt)</code> Description Reads a line of input from the user. If a prompt string is provided, it is displayed before reading input. Parameters <code>prompt</code> (optional, string) \u2013 The text to display before waiting for input. Return Type <code>string</code> (the user's input) Errors Throws an error if more than one argument is provided. Example <code>input(\"Enter your name: \")</code> \u2192 Displays <code>Enter your name:</code> and waits for input.<code>input()</code> \u2192 Waits for input with no prompt."},{"location":"standard-library/io/#printprintln","title":"print/println","text":"Property Details Function <code>print(args...)</code>, <code>println(args...)</code> Description Prints one or more arguments as a single concatenated string. <code>println</code> appends a newline at the end. Parameters <code>args...</code> (any type) \u2013 One or more values to print. Return Type <code>None</code> Errors None. Example <code>print(\"Hello, \", \"world!\")</code> \u2192 Prints <code>Hello, world!</code><code>println(\"Hello\")</code> \u2192 Prints <code>Hello</code> followed by a newline."},{"location":"standard-library/list/","title":"List","text":""},{"location":"standard-library/list/#append","title":"append","text":"Property Details Function <code>append(list, element)</code> Description Appends an element to a list. The first argument must be a list, and the second argument is the element to append to the list. Returns a new list with the appended element. Parameters <code>list</code> (List) \u2013 A list to which an element will be appended.<code>element</code> (Any Type) \u2013 The element to append to the list. Return Type <code>List</code> \u2013 A new list containing the appended element. Errors If the first argument is not a list, an error will occur.If the number of arguments is not exactly two, an error will occur. Example <code>append([1, 2, 3], 4)</code> \u2192 <code>[1, 2, 3, 4]</code>"},{"location":"standard-library/list/#range","title":"range","text":"Property Details Function <code>range(start, end)</code> Description Creates a range of numbers starting from start (inclusive) and ending at end (exclusive). Returns a list of numbers in the specified range. Parameters <code>start</code> (Number) \u2013 The starting number of the range.<code>end</code> (Number) \u2013 The ending number of the range. Return Type <code>List</code> \u2013 A list of numbers from start to end (exclusive). Errors If the first or second argument is not a number, an error will occur.If the number of arguments is not exactly two, an error will occur. Example <code>range(1, 5)</code> \u2192 <code>[1, 2, 3, 4]</code>"},{"location":"standard-library/list/#removeat","title":"removeat","text":"Property Details Function <code>removeat(list, index)</code> Description Removes the element at the specified index from the list. Returns a new list with the element at the given index removed. Parameters <code>list</code> (List) \u2013 The list from which to remove an element.<code>index</code> (Number) \u2013 The index of the element to remove from the list. Return Type <code>List</code> \u2013 A new list with the specified element removed. Errors If the first argument is not a list, an error will occur.If the second argument is not a number, an error will occur.If the index is out of range, an error will occur. Example <code>removeat([1, 2, 3, 4], 2)</code> \u2192 <code>[1, 2, 4]</code>"},{"location":"standard-library/list/#remove","title":"remove","text":"Property Details Function <code>remove(list, element)</code> Description Removes the first occurrence of element from the list. Returns a new list with the element removed. Parameters <code>list</code> (List) \u2013 The list from which to remove an element.<code>element</code> (Any Type) \u2013 The element to remove from the list. Return Type <code>List</code> \u2013 A new list with the specified element removed. Errors If the first argument is not a list, an error will occur.If the number of arguments is not exactly two, an error will occur. Example <code>remove([1, 2, 3, 4], 3)</code> \u2192 <code>[1, 2, 4]</code>"},{"location":"standard-library/math/","title":"Math","text":""},{"location":"standard-library/math/#abs","title":"abs","text":"Property Details Function <code>abs(number)</code> Description Returns the absolute value of the given number. Parameters <code>number</code> (Number) \u2013 The number for which to return the absolute value. Return Type <code>Number</code> \u2013 The absolute value of the provided number. Errors If the argument is not a number, an error will occur.If the number of arguments is not exactly one, an error will occur. Example <code>abs(-5)</code> \u2192 <code>5</code><code>abs(3)</code> \u2192 <code>3</code>"},{"location":"standard-library/math/#ceil","title":"ceil","text":"Property Details Function <code>ceil(number)</code> Description Returns the smallest integer greater than or equal to the given number. Parameters <code>number</code> (Number) \u2013 The number for which to return the ceiling value. Return Type <code>Number</code> \u2013 The smallest integer greater than or equal to the provided number. Errors If the argument is not a number, an error will occur.If the number of arguments is not exactly one, an error will occur. Example <code>ceil(4.2)</code> \u2192 <code>5</code><code>ceil(-1.7)</code> \u2192 <code>-1</code>"},{"location":"standard-library/math/#cos","title":"cos","text":"Property Details Function <code>cos(number)</code> Description Returns the cosine of the given number (interpreted as an angle in radians). Parameters <code>number</code> (Number) \u2013 The angle in radians for which to compute the cosine value. Return Type <code>Number</code> \u2013 The cosine of the provided angle. Errors If the argument is not a number, an error will occur.If the number of arguments is not exactly one, an error will occur. Example <code>cos(0)</code> \u2192 <code>1</code>"},{"location":"standard-library/math/#floor","title":"floor","text":"Property Details Function <code>floor(x)</code> Description Returns the largest integer less than or equal to x. Parameters <code>x</code> (Number) \u2013 The number to round down. Return Type <code>Number</code> Errors Throws an error if x is not a number. Example <code>floor(3.7)</code> \u2192 <code>3</code><code>floor(-2.3)</code> \u2192 <code>-3</code>"},{"location":"standard-library/math/#pow","title":"pow","text":"Property Details Function <code>pow(base, exponent)</code> Description Returns base raised to the power of exponent. Parameters <code>base</code> (Number) \u2013 The base value.<code>exponent</code> (Number) \u2013 The exponent value. Return Type <code>Number</code> Errors Throws an error if arguments are not numbers. Example <code>pow(2, 3)</code> \u2192 <code>8</code><code>pow(5, 0.5)</code> \u2192 <code>2.236</code>"},{"location":"standard-library/math/#sin","title":"sin","text":"Property Details Function <code>sin(angle)</code> Description Returns the sine of angle, where angle is given in radians. Parameters <code>angle</code> (Number) \u2013 The angle in radians. Return Type <code>Number</code> Errors Throws an error if the argument is not a number. Example <code>sin(0)</code> \u2192 <code>0</code><code>sin(3.14159 / 2)</code> \u2192 <code>1</code>"},{"location":"standard-library/math/#sqrt","title":"sqrt","text":"Property Details Function <code>sqrt(number)</code> Description Returns the square root of number. Parameters <code>number</code> (Number) \u2013 The value to find the square root of. Return Type <code>Number</code> Errors Throws an error if the argument is not a number. Example <code>sqrt(9)</code> \u2192 <code>3</code><code>sqrt(2)</code> \u2192 <code>1.41421</code>"},{"location":"standard-library/math/#tan","title":"tan","text":"Property Details Function <code>tan(number)</code> Description Returns the tangent of number, where number is in radians. Parameters <code>number</code> (Number) \u2013 The angle in radians. Return Type <code>Number</code> Errors Throws an error if the argument is not a number. Example <code>tan(0)</code> \u2192 <code>0</code><code>tan(pi / 4)</code> \u2192 <code>1</code>"},{"location":"standard-library/string/","title":"String","text":""},{"location":"standard-library/string/#concat","title":"concat","text":"Property Details Function <code>concat(value1, value2, ...)</code> Description Concatenates all given values into a single string. Parameters Any number of values of any type. Each value is converted to a string before concatenation. Return Type <code>String</code> Errors None. All values are implicitly converted to strings. Example <code>concat(\"Hello\", \" \", \"World!\")</code> \u2192 <code>\"Hello World!\"</code><code>concat(42, \" is the answer\")</code> \u2192 <code>\"42 is the answer\"</code>"},{"location":"standard-library/string/#len","title":"len","text":"Property Details Function <code>len(value)</code> Description Returns the length of a string or list. Parameters <code>value</code> \u2013 A string or list. Return Type <code>Number</code> \u2013 The length of the string or list. Errors Throws an error if the argument is not a string or list. Example <code>len(\"Hello\")</code> \u2192 <code>5</code><code>len([1, 2, 3, 4])</code> \u2192 <code>4</code>"}]}