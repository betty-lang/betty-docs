{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the official documentation for Betty, a dynamic programming language designed for prototyping purposes. Betty supports various data types, a standard library, and offers a simple and intuitive syntax.</p> <p>Warning</p> <p>This documentation is still a work in progress and does not cover all language features yet. Please check back for future updates!</p>"},{"location":"data-types/boolean/","title":"Boolean","text":"<p>Boolean literals are represented with the <code>true</code> and <code>false</code> keywords, which are language-reserved and may not be used in another context. Logical operations in Betty require both operands to be of type <code>Boolean</code>. No implicit conversions between booleans and numeric values exist.</p> <pre><code>a = true;\n</code></pre>"},{"location":"data-types/char/","title":"Char","text":"<p>Character literals are encased between a pair of single quotes ( <code>'</code> ). Empty character literals are not allowed in Betty programs. A character literal may not consist of more than one character, save for escape sequences \u2013 which essentially are single characters.</p> <pre><code>x = 'b';    # Valid\nx = '\\n';   # Valid, escape sequence\nx = '';     # Will throw, empty character literal\nx = 'ab';   # Will throw, multi-character literal\nx = ';      # Will throw, unterminated character literal\n</code></pre> <p>Note</p> <p>Some operations between numbers and characters (character arithmetic) are handled implicitly by the interpreter, to an extent. Refer to the operator documentation syntax for further details, as well as to explore options for handling such operations explicitly.</p>"},{"location":"data-types/list/","title":"List","text":"<p>Lists are currently the sole data structure of the Betty language, its bread and butter so to speak. Aided by the language's dynamic design, lists are very versatile in terms of their usage and what they can accomplish.</p> <p>Betty allows lists containing multiple data types, even different (nested) lists. Despite the lack of other data structures in the language, the flexibility achieved through this alone enables for \"custom\" record-like structures, even \u2013 admittedly lesser-performing \u2013 maps.</p> <p>Note</p> <p>In the code examples section of the documentation, you can find a partial, preliminary attempt at bootstrapping (self-hosting) the Betty interpreter, showcasing the language's potential. Naturally, although such an implementation would result in less-than-ideal execution times, it is nonetheless a rather fun theoretical endeavor to take on.</p> <p>Betty is primarily a prototyping language, that much is certain. Be that as it may, the presence of lists \u2013 along with some useful standard library functions, can assist the user in coding solutions to a multitude of problems. That was a major consideration in the way lists are implemented.</p> <p>One of the goals in the development process was to provide the programmer with ways to create something more meaningful than your typical \"Hello World,\" even at the cost of potential performance (the unavoidable tree-walk interpreter baggage). Whether they decide to \"get their hands dirty\" is ultimately left up to the user.</p> <pre><code>x = [1, 2, 3, 4];\nx = [1..5];             # Same declaration with range syntax\nx = [[1, 2], [3, 4]];   # Nested lists\n</code></pre>"},{"location":"data-types/list/#string-indexing","title":"String indexing","text":"<p>Betty supports indexing strings and accessing them as character lists out-of-the-box, in alignment with the default behavior in various programming languages.</p> <pre><code>print(\"hello\"[1]); # Will print `e`\n</code></pre>"},{"location":"data-types/none/","title":"None","text":"<p><code>None</code> is a special data type, in terms of how it works in Betty. It is not one of the language's keywords and neither variables nor functions can be assigned it. </p> <p>Nullability support can be a rather controversial topic among language designers, as including support for it could potentially lead to a plethora of runtime errors, like when dereferencing null pointers.</p> <p>What is more, extending a language to support null and nullable types can introduce a whole new layer of complexity (oftentimes unnecessary).</p> <p>However, allowing implicit returns of a <code>unit</code>-like value (<code>None</code>, in our case) can be beneficial in handling cases like the default return value of functions. Betty is a dynamic language, therefore a single function can return multiple data types. Introducing a default return value mitigates a significant class of potential issues and ensures all code paths have a return value.</p> <p>Under the hood, it is far more convenient to implement a visitor pattern in the interpreter, when all node visits result in the return of a uniform <code>Value</code> struct (with <code>None</code> as a potential value type). In this manner, there's no need for special handling of uninitialized or absent returns in dynamic typing contexts. It also avoids runtime surprises when a function unexpectedly fails to return a value.</p> <p>It should further be noted that since Betty allows expression-statements as first-class citizens, functions can be executed solely for their side effects and have their values discarded.</p> <pre><code>print(\"Hello, world!\"); # Valid, clearly intended for the side effect.\n</code></pre>"},{"location":"data-types/number/","title":"Number","text":"<p>Betty uses a universal <code>number</code> data type to represent both integers and real numbers. Internally, all numeric values are stored as <code>double</code> for ease of handling. The language does, in fact, offer ways to work with strictly integer values, at least on the surface level, should one wish to do so.</p> <p>For instance, there are built-in math functions baked into the language for both <code>floor()</code> and <code>ceil()</code>. Additionally, there exists an integer division operator ( <code>//</code> ), which performs normal double division then floors the result, as is the case in several programming languages (e.g. Python, Ruby).</p> <pre><code>12\n0.5\n0.002\n-3\n</code></pre> <p>Under the hood, Betty leverages C#'s and, by extension, .NET's own <code>double</code> primitive value type, which means edge cases such as <code>infinity</code> and <code>NaN</code> are handled by the underlying framework implementation at the binary level.</p>"},{"location":"data-types/string/","title":"String","text":"<p>Strings in Betty are enclosed between a pair of double quotes ( <code>\"</code> ). They are interned using a string lookup table so they can be lightweight \u2013 in terms of memory overhead and allocations (on the stack vs. the heap), as well as be accessed very fast in ideal usage scenarios.</p> <pre><code>\"Hello, World!\";\n</code></pre> <p>In an addition operation, if either operand is a <code>string</code>, then the result is concatenated and returned as a <code>string</code>. This has been implemented to match the expected behavior in several programming languages.</p> <pre><code>\"Hi \" + 5; # Returns \"Hi 5\"\n</code></pre> <p>Furthermore, in addition to equality and inequality operations, strings allow comparisons like <code>&gt;</code> and <code>&lt;</code>, based on lexicographical order. This behavior may not always make intuitive sense to a newer programmer, nonetheless it is supported in plenty of programming languages. In the back-end, C#'s <code>CompareTo</code> standard library function (akin to <code>strcmp</code> in C) is utilized.</p> <pre><code>\"apple\" &lt; \"banana\"; # Returns `true`, since 'a' is less than 'b'\n</code></pre> <p>Compound (shorthand assignment) is supported in strings only through the addition ( <code>+</code> ) operator.</p>"},{"location":"data-types/string/#escape-sequences","title":"Escape sequences","text":"Sequence Description <code>\\n</code> Newline <code>\\t</code> Tab <code>\\\"</code> Double quote <code>\\'</code> Single quote <code>\\\\</code> Backslash <code>\\0</code> Null character <p>Note</p> <p>Character literals also support the aforementioned sequences.</p>"}]}